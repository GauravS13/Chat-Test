<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎮 Decentralized Game Room - Single File Edition</title>
    <style>
        /* Modern CSS Reset */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        /* CSS Custom Properties for consistent theming */
        :root {
            --primary-color: #6366f1;
            --primary-hover: #5b5cf6;
            --secondary-color: #10b981;
            --secondary-hover: #059669;
            --accent-color: #f59e0b;
            --accent-hover: #d97706;
            --danger-color: #ef4444;
            --danger-hover: #dc2626;
            --background-primary: #0f172a;
            --background-secondary: #1e293b;
            --background-tertiary: #334155;
            --surface-primary: #1e293b;
            --surface-secondary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #475569;
            --border-hover: #64748b;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;
        }
        
        /* Base Styles */
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--background-primary) 0%, #1a202c 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Container */
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            padding: clamp(1rem, 4vw, 2rem);
            padding-top: clamp(4rem, 8vw, 6rem);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        
        /* Header */
        .header { 
            text-align: center; 
            margin-bottom: clamp(2rem, 5vw, 3rem);
            padding: clamp(1.5rem, 4vw, 2rem) clamp(1rem, 3vw, 2rem);
            background: var(--surface-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
        }
        
        .header h1 { 
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 800;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 200%;
            animation: gradientShift 3s ease-in-out infinite;
        }
        
        .header p {
            font-size: 1.125rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        /* Lobby */
        .lobby { 
            text-align: center; 
            margin-bottom: clamp(1.5rem, 4vw, 2rem);
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 60vh;
        }
        
        .lobby h2 {
            font-size: clamp(1.5rem, 4vw, 2rem);
            font-weight: 700;
            margin-bottom: clamp(1.5rem, 4vw, 2rem);
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        /* Buttons */
        .btn { 
            background: var(--primary-color);
            color: white;
            border: none;
            padding: clamp(0.75rem, 2vw, 1rem) clamp(1.5rem, 4vw, 2rem);
            margin: clamp(0.375rem, 1vw, 0.5rem);
            border-radius: var(--radius-lg);
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: min(200px, 80vw);
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover { 
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        
        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-md);
        }
        
        .btn:disabled { 
            background: var(--background-tertiary);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn.offline { 
            background: var(--accent-color);
        }
        
        .btn.offline:hover { 
            background: var(--accent-hover);
        }
        
        .btn.back-btn { 
            background: var(--background-tertiary);
            margin-top: 1.5rem;
        }
        
        .btn.back-btn:hover { 
            background: var(--surface-secondary);
        }
        
        /* Game Selection Grid */
        .game-selection { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(min(280px, 100%), 1fr)); 
            gap: clamp(1rem, 3vw, 1.5rem); 
            margin: clamp(1.5rem, 4vw, 2rem) 0;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }
        
        .game-btn { 
            font-size: clamp(1rem, 3vw, 1.25rem); 
            padding: clamp(1.5rem, 4vw, 2rem); 
            min-height: clamp(100px, 15vw, 120px);
            background: var(--surface-primary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            touch-action: manipulation;
        }
        
        .game-btn:hover {
            background: var(--primary-color);
            border-color: var(--primary-hover);
            color: white;
        }
        
        /* Game Boards */
        .game-board { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr);
            gap: clamp(0.5rem, 2vw, 0.75rem); 
            max-width: min(360px, 90vw); 
            margin: clamp(1.5rem, 4vw, 2rem) auto;
            padding: clamp(1rem, 3vw, 1.5rem);
            background: var(--surface-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-lg);
            width: 100%;
            aspect-ratio: 1;
        }
        
        .cell { 
            width: 100%; 
            aspect-ratio: 1; 
            background: var(--surface-secondary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            display: flex; 
            align-items: center; 
            justify-content: center;
            font-size: clamp(1.5rem, 6vw, 2.5rem); 
            font-weight: bold; 
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            touch-action: manipulation;
            min-height: 60px;
        }
        
        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--primary-color);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .cell:hover::before {
            opacity: 0.1;
        }
        
        .cell:hover { 
            border-color: var(--primary-color);
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }
        
        .cell.x { 
            color: var(--danger-color);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .cell.o { 
            color: var(--secondary-color);
            background: rgba(16, 185, 129, 0.1);
        }
        
        /* Connect Four Board */
        .connect4-board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(6, 1fr);
            gap: clamp(0.25rem, 1vw, 0.5rem);
            max-width: min(500px, 95vw);
            margin: clamp(1.5rem, 4vw, 2rem) auto;
            background: linear-gradient(135deg, #1e40af, #3b82f6);
            padding: clamp(1rem, 3vw, 1.5rem);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            width: 100%;
            aspect-ratio: 7/6;
        }
        
        .connect4-cell {
            width: 100%;
            aspect-ratio: 1;
            background: var(--surface-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            touch-action: manipulation;
            min-width: 30px;
            min-height: 30px;
        }

        .connect4-cell.non-clickable {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .connect4-cell:not(.non-clickable):hover {
            background: var(--surface-secondary);
            transform: scale(1.1);
            border-color: var(--primary-color);
            cursor: pointer;
        }
        
        .connect4-cell.red { 
            background: linear-gradient(135deg, var(--danger-color), #dc2626);
            box-shadow: 0 4px 8px rgba(239, 68, 68, 0.3);
        }
        
        .connect4-cell.yellow { 
            background: linear-gradient(135deg, var(--accent-color), #d97706);
            box-shadow: 0 4px 8px rgba(245, 158, 11, 0.3);
        }
        
        /* Number Guessing */
        .numguess-input {
            padding: clamp(0.75rem, 2vw, 1rem);
            margin: clamp(0.75rem, 2vw, 1rem);
            font-size: clamp(1rem, 3vw, 1.25rem);
            border-radius: var(--radius-lg);
            border: 2px solid var(--border-color);
            background: var(--surface-primary);
            color: var(--text-primary);
            text-align: center;
            width: min(200px, 80vw);
            max-width: 100%;
            transition: all 0.3s;
            box-shadow: var(--shadow-sm);
        }
        
        .numguess-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        
        /* Game Info */
        .game-info {
            background: var(--surface-primary);
            padding: clamp(1rem, 3vw, 1.5rem);
            border-radius: var(--radius-xl);
            margin: clamp(1.5rem, 4vw, 2rem) auto;
            text-align: center;
            max-width: min(600px, 95vw);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            width: 100%;
        }
        
        .score-display {
            font-size: clamp(1.125rem, 3vw, 1.5rem);
            font-weight: 600;
            margin: 1rem 0;
            padding: clamp(0.75rem, 2vw, 1rem);
            background: var(--surface-secondary);
            border-radius: var(--radius-lg);
            color: var(--text-primary);
        }
        
        /* Status Messages */
        .status { 
            padding: clamp(0.75rem, 2vw, 1rem); 
            margin: clamp(0.75rem, 2vw, 1rem) 0; 
            border-radius: var(--radius-lg);
            font-weight: 600;
            text-align: center;
            box-shadow: var(--shadow-sm);
            font-size: clamp(0.9rem, 2.5vw, 1rem);
        }
        
        .status.waiting { 
            background: rgba(245, 158, 11, 0.2); 
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }
        
        .status.connected { 
            background: rgba(16, 185, 129, 0.2); 
            color: var(--secondary-color);
            border: 1px solid var(--secondary-color);
        }
        
        .status.error { 
            background: rgba(239, 68, 68, 0.2); 
            color: var(--danger-color);
            border: 1px solid var(--danger-color);
        }
        
        .status.offline { 
            background: rgba(148, 163, 184, 0.2); 
            color: var(--text-muted);
            border: 1px solid var(--text-muted);
        }
        
        .status.info {
            background: rgba(99, 102, 241, 0.2);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .status.warning {
            background: rgba(245, 158, 11, 0.2);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }
        
        /* Loader */
        .loader {
            border: 3px solid var(--surface-secondary);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 0.75rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Game Over Actions */
        .game-over-actions {
            text-align: center;
            margin-top: clamp(1.5rem, 4vw, 2rem);
            padding: clamp(1rem, 3vw, 1.5rem);
            background: var(--surface-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }
        
        /* Debug Panel */
        .debug-panel { 
            position: fixed; 
            top: 0.5rem; 
            right: 0.5rem;
            background: rgba(15, 23, 42, 0.92);
            backdrop-filter: blur(8px);
            padding: 0.4rem 0.6rem;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            width: 160px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .debug-panel:hover {
            opacity: 1;
        }
        
        .debug-panel h3 { 
            color: var(--primary-color);
            margin-bottom: 0.3rem;
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
        }
        
        .debug-item { 
            margin: 0.2rem 0;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.6rem;
            line-height: 1.1;
        }
        
        .debug-item strong { 
            color: var(--text-primary);
            font-size: 0.55rem;
            max-width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--surface-primary);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border-color);
            max-width: min(600px, 95vw);
            max-height: 90vh;
            width: 100%;
            overflow-y: auto;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1) translateY(0);
        }
        
        .modal-header {
            padding: clamp(1.5rem, 4vw, 2rem);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .modal-header h3 {
            font-size: clamp(1.25rem, 3vw, 1.5rem);
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: var(--radius-md);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
        }
        
        .modal-close:hover {
            background: var(--surface-secondary);
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: clamp(1.5rem, 4vw, 2rem);
        }
        
        .manual-handshake { 
            background: transparent;
            padding: 0;
            border-radius: 0;
            margin: 0;
            border: none;
            box-shadow: none;
            max-width: 100%;
            overflow-x: auto;
        }
        
        .manual-handshake h4 { 
            color: var(--primary-color);
            margin-bottom: clamp(0.75rem, 2vw, 1rem);
            font-size: clamp(1rem, 2.5vw, 1.125rem);
            font-weight: 600;
        }
        
        .manual-handshake p { 
            margin: clamp(0.375rem, 1vw, 0.5rem) 0;
            color: var(--text-secondary);
            font-size: clamp(0.875rem, 2vw, 1rem);
            line-height: 1.5;
        }
        
        .manual-handshake textarea {
            width: 100%;
            min-height: clamp(100px, 15vw, 120px);
            background: var(--background-primary);
            color: var(--primary-color);
            border: 1px solid var(--border-color);
            padding: clamp(0.75rem, 2vw, 1rem);
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            margin: clamp(0.75rem, 2vw, 1rem) 0;
            border-radius: var(--radius-md);
            resize: vertical;
            transition: border-color 0.3s;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            line-height: 1.4;
        }
        
        .manual-handshake textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }
        
        /* Utility Classes */
        .hidden { 
            display: none !important; 
        }
        
        /* Smooth transitions for better UX */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Focus styles for accessibility */
        .btn:focus-visible,
        .cell:focus-visible,
        .connect4-cell:focus-visible,
        .game-btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        /* Loading states */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* Better scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--surface-secondary);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-lg);
            font-weight: 600;
            border: 1px solid var(--danger-color);
        }
        
        /* Enhanced Responsive Design */
        @media (max-width: 1024px) {
            .container {
                padding: 1.5rem;
            }
            
            .game-selection {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }
        
        @media (max-width: 768px) {
            .container { 
                padding: 1rem; 
            }
            
            .btn { 
                min-width: min(160px, 80vw); 
                padding: 0.875rem 1.5rem;
                font-size: clamp(0.875rem, 2.5vw, 0.9rem);
                width: 100%;
                max-width: 300px;
            }
            
            .game-selection {
                grid-template-columns: 1fr;
                gap: 1rem;
                max-width: 400px;
            }
            
            .lobby {
                min-height: 50vh;
            }
            
            .game-btn {
                min-height: 100px;
                padding: 1.5rem;
            }
            
            .debug-panel {
                position: fixed;
                top: 0.25rem;
                right: 0.25rem;
                width: 140px;
                font-size: 0.65rem;
                padding: 0.3rem 0.5rem;
                z-index: 1001;
            }
            
            .manual-handshake textarea {
                min-height: 100px;
                font-size: 0.875rem;
            }
        }
        
        @media (max-width: 480px) {
            .header {
                margin-bottom: 1.5rem;
                padding: 1.5rem 1rem;
            }
            
            .header h1 {
                font-size: clamp(1.75rem, 8vw, 2rem);
            }
            
            .header p {
                font-size: clamp(0.9rem, 3vw, 1rem);
            }
            
            .btn {
                padding: 0.75rem 1rem;
                min-width: auto;
                width: 100%;
            }
            
            .game-board {
                gap: 0.5rem;
                padding: 1rem;
            }
            
            .debug-panel {
                position: fixed;
                top: 0.1rem;
                right: 0.1rem;
                width: 120px;
                font-size: 0.6rem;
                padding: 0.25rem 0.4rem;
                z-index: 1002;
                opacity: 0.75;
            }
            
            .debug-panel h3 {
                font-size: 0.7rem;
                margin-bottom: 0.3rem;
            }
            
            .debug-item {
                margin: 0.2rem 0;
                font-size: 0.6rem;
            }
            
            .debug-item strong {
                font-size: 0.55rem;
            }
            
            .manual-handshake {
                padding: 1rem;
            }
            
            .manual-handshake textarea {
                min-height: 80px;
                padding: 0.75rem;
                font-size: 0.8rem;
            }
            
            .game-over-actions {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .game-over-actions .btn {
                width: 100%;
                max-width: 250px;
            }
        }
        
        @media (max-width: 360px) {
            .container {
                padding: 0.75rem;
            }
            
            .header {
                padding: 1rem 0.75rem;
            }
            
            .game-board {
                padding: 0.75rem;
                gap: 0.375rem;
            }
            
            .btn {
                padding: 0.625rem 0.75rem;
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 Decentralized Game Room</h1>
            <p>P2P Gaming with Offline-First Design</p>
        </div>
        
        <!-- Lobby View -->
        <div id="lobby" class="lobby">
            <h2>Choose Your Game</h2>

            <!-- Connection Status Indicator -->
            <div id="lobbyConnectionStatus" class="connection-status hidden" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--surface-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-color);">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div>
                        <span style="color: var(--secondary-color); font-weight: 600;">🔗 Connected to: </span>
                        <span id="lobbyPeerName" style="color: var(--text-primary);"></span>
                    </div>
                    <button class="btn" style="background: var(--danger-color);" onclick="appState.disconnectFromPeer()">Disconnect</button>
                </div>
                <div style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">
                    You can play multiple games with this connection!
                </div>
            </div>

            <div class="game-selection">
                <button class="btn game-btn" onclick="selectGame('tictactoe')">🎯 Tic-Tac-Toe</button>
                <button class="btn game-btn" onclick="selectGame('connect4')">🔴 Connect Four</button>
                <button class="btn game-btn" onclick="selectGame('numguess')">🔢 Number Guessing</button>
            </div>

            <div class="room-selection" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
                <h3 style="margin-bottom: 1rem; color: var(--text-secondary);">Or Connect with Friends</h3>
                <div style="display: flex; flex-direction: column; gap: 1rem; max-width: 300px; margin: 0 auto;">
                    <button class="btn" onclick="createRoom()">🔗 Create Room</button>
                    <button class="btn" onclick="joinRoom()">📋 Join Room</button>
                </div>
            </div>
        </div>
        
        <!-- Game Mode Selection -->
        <div id="gameMode" class="lobby hidden">
            <h2 id="selectedGameTitle">Game Selected</h2>
            <button class="btn offline" onclick="playVsAI()">Play vs AI</button>
            <button class="btn offline" onclick="playHotseat()">Hotseat (Offline)</button>
            <button class="btn back-btn" onclick="backToGameSelection()">Back to Games</button>
        </div>
        
        <!-- Room Info View (No longer needed - removed room ID functionality) -->
        
        <!-- Game View -->
        <div id="game" class="hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2 id="gameTitle">Game</h2>
                <div id="connectionControls" style="display: flex; gap: 0.75rem; align-items: center;">
                    <div id="playerNamesDisplay" style="font-size: 0.875rem; color: var(--text-secondary); display: none;">
                        <span id="player1Display">Player 1</span> vs <span id="player2Display">Player 2</span>
                    </div>
                    <button id="disconnectBtn" class="btn" style="background: var(--danger-color); display: none;" onclick="appState.disconnectFromPeer()">
                        🔌 Disconnect
                    </button>
                </div>
            </div>

            <!-- Tic-Tac-Toe Board -->
            <div id="tictactoeBoard" class="game-board hidden"></div>
            
            <!-- Connect Four Board -->
            <div id="connect4Board" class="connect4-board hidden"></div>
            
            
            <!-- Number Guessing Game -->
            <div id="numguessControls" class="hidden">
                <div class="game-info">
                    <div id="numguessInfo">Guess a number between 1 and 100!</div>
                    <div id="numguessAttempts">Attempts: 0</div>
                </div>
                <input type="number" id="numguessInput" class="numguess-input" placeholder="Enter your guess" min="1" max="100">
                <button class="btn" onclick="makeNumGuess()">Guess!</button>
            </div>
            
            <!-- Game Info Panel -->
            <div id="gameInfo" class="game-info">
                <div id="scoreDisplay" class="score-display"></div>
                <div class="status" id="gameStatus">Your turn!</div>
            </div>
            
            <!-- Game Over Actions -->
            <div id="gameOverActions" class="game-over-actions hidden">
                <button class="btn" onclick="rematchGame()">Rematch</button>
                <button class="btn back-btn" onclick="backToGameSelection()">Home</button>
            </div>
            
            <button class="btn back-btn" onclick="backToGameSelection()">Back to Games</button>
        </div>
        
        <!-- Manual Handshake Modal -->
        <div id="handshakeModal" class="modal-overlay">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Manual P2P Handshake</h3>
                    <button class="modal-close" onclick="closeHandshakeModal()" aria-label="Close modal">
                        ×
                    </button>
                </div>
                <div class="modal-body">
                    <div class="manual-handshake">
                        <!-- Mode Selection -->
                        <div id="modeSelection">
                            <!-- Player Name Input -->
                            <div style="margin: 1.5rem 0;">
                                <h5 style="margin-bottom: 0.75rem; color: var(--text-secondary);">Your Name (optional):</h5>
                                <div>
                                    <input type="text" id="myName" placeholder="Your name" maxlength="20" style="width: 100%; padding: 0.75rem; background: var(--background-primary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: var(--radius-md); font-size: 0.875rem;" />
                                </div>
                            </div>

                            <div style="display: flex; flex-direction: column; gap: 1rem; margin-top: 1rem;">
                                <button class="btn" onclick="startCreateMode()">🔗 Generate Link for Friend<span id="createLoader" class="loader hidden"></span></button>
                                <button class="btn" onclick="startJoinMode()">📋 I Have a Link</button>
                            </div>
                        </div>
                        
                        <!-- CREATE MODE: Generate offer for sharing -->
                        <div id="createMode" class="hidden">
                            <h4>Step 1: Share this offer with your friend</h4>
                            <textarea id="offerText" readonly style="width: 100%; height: 120px; background: var(--background-primary); color: var(--secondary-color); border: 1px solid var(--border-color); padding: 1rem; font-family: 'JetBrains Mono', monospace; margin: 1rem 0; border-radius: var(--radius-md); font-size: 0.875rem; line-height: 1.4;"></textarea>
                            <button class="btn" onclick="copyToClipboard('offerText')">📋 Copy Offer</button>
                            
                            <h4 style="margin-top: 2rem;">Step 2: Paste the answer you receive back</h4>
                            <textarea id="answerInput" placeholder="Paste the answer your friend sends back..." style="width: 100%; height: 120px; background: var(--background-primary); color: var(--secondary-color); border: 1px solid var(--border-color); padding: 1rem; font-family: 'JetBrains Mono', monospace; margin: 1rem 0; border-radius: var(--radius-md); font-size: 0.875rem; line-height: 1.4;"></textarea>
                            <button class="btn" onclick="processReceivedAnswer()">🔗 Connect with Answer</button>
                        </div>
                        
                        <!-- JOIN MODE: Process offer and generate answer -->
                        <div id="joinMode" class="hidden">
                            <h4>Step 1: Paste the offer you received</h4>
                            <textarea id="receivedOfferInput" placeholder='Paste the encoded offer here (compressed for easy sharing)' style="width: 100%; height: 120px; background: var(--background-primary); color: var(--secondary-color); border: 1px solid var(--border-color); padding: 1rem; font-family: 'JetBrains Mono', monospace; margin: 1rem 0; border-radius: var(--radius-md); font-size: 0.875rem; line-height: 1.4;"></textarea>
                            <button class="btn" onclick="processReceivedOffer()">⚡ Generate Answer<span id="answerLoader" class="loader hidden"></span></button>
                            
                            <!-- Answer generated - show to user -->
                            <div id="generatedAnswerSection" class="hidden">
                                <h4 style="margin-top: 2rem;">Step 2: Send this answer back to your friend</h4>
                                <textarea id="answerText" readonly style="width: 100%; height: 120px; background: var(--background-primary); color: var(--secondary-color); border: 1px solid var(--border-color); padding: 1rem; font-family: 'JetBrains Mono', monospace; margin: 1rem 0; border-radius: var(--radius-md); font-size: 0.875rem; line-height: 1.4;"></textarea>
                                <button class="btn" onclick="copyToClipboard('answerText')">📋 Copy Answer</button>
                                <div class="status info" style="margin-top: 1rem;">✅ Answer generated! Copy and send it back. Connection will establish automatically.</div>
                            </div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color);">
                            <button class="btn back-btn" onclick="resetHandshakeModal()">🔄 Back to Mode Selection</button>
                            <button class="btn back-btn" onclick="closeHandshakeModal()">❌ Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <script>
        // Pure JavaScript SDP Encoding/Decoding utilities for shorter strings
        function simpleCompress(text) {
          
            // Use a much simpler and safer approach - just basic base64 encoding
            // The pattern replacement was causing issues, so let's use a more reliable method
            let compressed = text;

            // Only replace line breaks to make it more compact
            compressed = compressed.replace(/\r\n/g, '|').replace(/\n/g, '|');
            return compressed;
        }

        function simpleDecompress(compressed) {
            // Simple decompression - just restore line breaks
            let decompressed = compressed.replace(/\|/g, '\r\n');

        
            return decompressed;
        }

        function encodeSDP(obj) {
            try {
                const json = JSON.stringify(obj);
                const compressed = simpleCompress(json);
                return btoa(compressed)
                    .replace(/\+/g, '-')  // base64url safe
                    .replace(/\//g, '_')
                    .replace(/=+$/, '');  // strip padding
            } catch (error) {
                console.error('Error encoding SDP:', error);
                return null;
            }
        }

        function decodeSDP(encodedStr) {
            try {
                console.log('Decoding SDP, input length:', encodedStr.length);
                console.log('Input starts with:', encodedStr.substring(0, 50));
                
                // Restore base64url to base64
                const base64 = encodedStr
                    .replace(/-/g, '+')
                    .replace(/_/g, '/');
                console.log('Base64 conversion done, length:', base64.length);
                
                // Add padding if needed
                const padding = base64.length % 4;
                const paddedBase64 = padding ? base64 + '='.repeat(4 - padding) : base64;
                console.log('Padding added, final length:', paddedBase64.length);
                
                const decompressed = atob(paddedBase64);
                console.log('Base64 decoded, length:', decompressed.length);
                
                const json = simpleDecompress(decompressed);
                console.log('Decompressed, length:', json.length);
                console.log('JSON starts with:', json.substring(0, 100));
                
                const result = JSON.parse(json);
                console.log('Successfully parsed JSON, type:', result.type);
                
                return result;
            } catch (error) {
                console.error('Error decoding SDP:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
                console.error('Input string:', encodedStr);
                return null;
            }
        }

        // Memory-optimized multi-game engine
        class GameEngine {
            constructor() {
                this.gameType = 'tictactoe';
                this.reset();
                this.MAX_HISTORY = 50; // Memory optimization: limit move history
            }
            
            setGameType(type) {
                this.gameType = type;
                this.reset();
            }
            
            reset() {
                this.currentPlayer = 'x';
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.score = { x: 0, o: 0, draws: 0 };
                
                switch(this.gameType) {
                    case 'tictactoe':
                        this.board = Array(9).fill('');
                        break;
                    case 'connect4':
                        this.board = Array(42).fill(''); // 7x6 grid
                        break;
                    case 'numguess':
                        this.targetNumber = Math.floor(Math.random() * 100) + 1;
                        this.attempts = 0;
                        this.maxAttempts = 7;
                        this.guesses = [];
                        break;
                }
            }
            
            makeMove(data) {
                switch(this.gameType) {
                    case 'tictactoe':
                        return this.makeTicTacToeMove(data);
                    case 'connect4':
                        return this.makeConnect4Move(data);
                    case 'numguess':
                        return this.makeNumGuessMove(data);
                }
                return false;
            }
            
            makeTicTacToeMove(index) {
                if (this.board[index] !== '' || this.gameOver) return false;
                
                this.board[index] = this.currentPlayer;
                this.moveHistory.push({player: this.currentPlayer, index: index});
                
                if (this.moveHistory.length > this.MAX_HISTORY) {
                    this.moveHistory.shift();
                }
                
                if (this.checkTicTacToeWin(index)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.score[this.currentPlayer]++;
                    return true;
                }
                
                if (this.checkTicTacToeDraw()) {
                    this.gameOver = true;
                    this.winner = 'draw';
                    this.score.draws++;
                    return true;
                }
                
                this.currentPlayer = this.currentPlayer === 'x' ? 'o' : 'x';
                return true;
            }
            
            makeConnect4Move(col) {
                if (this.gameOver || col < 0 || col > 6) return false;
                
                for (let row = 5; row >= 0; row--) {
                    const index = row * 7 + col;
                    if (this.board[index] === '') {
                        this.board[index] = this.currentPlayer;
                        this.moveHistory.push({player: this.currentPlayer, index: index});
                        
                        if (this.checkConnect4Win(index)) {
                            this.gameOver = true;
                            this.winner = this.currentPlayer;
                            this.score[this.currentPlayer]++;
                            return true;
                        }
                        
                        if (this.checkConnect4Draw()) {
                            this.gameOver = true;
                            this.winner = 'draw';
                            this.score.draws++;
                            return true;
                        }
                        
                        this.currentPlayer = this.currentPlayer === 'x' ? 'o' : 'x';
                        return true;
                    }
                }
                return false;
            }
            
            
            makeNumGuessMove(guess) {
                if (this.gameOver || this.attempts >= this.maxAttempts) return false;
                
                this.attempts++;
                this.guesses.push(guess);
                
                if (guess === this.targetNumber) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.score[this.currentPlayer]++;
                    return true;
                } else if (this.attempts >= this.maxAttempts) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer === 'x' ? 'o' : 'x';
                    this.score[this.winner]++;
                    return true;
                }
                
                return true;
            }
            
            checkTicTacToeWin(index) {
                const lines = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6] // diagonals
                ];
                
                return lines.some(line => 
                    line.includes(index) && 
                    this.board[line[0]] && 
                    this.board[line[0]] === this.board[line[1]] && 
                    this.board[line[1]] === this.board[line[2]]
                );
            }
            
            checkTicTacToeDraw() {
                return this.board.every(cell => cell !== '');
            }
            
            checkConnect4Win(index) {
                const row = Math.floor(index / 7);
                const col = index % 7;
                const player = this.board[index];
                
                // Check horizontal
                let count = 1;
                for (let c = col - 1; c >= 0 && this.board[row * 7 + c] === player; c--) count++;
                for (let c = col + 1; c < 7 && this.board[row * 7 + c] === player; c++) count++;
                if (count >= 4) return true;
                
                // Check vertical
                count = 1;
                for (let r = row - 1; r >= 0 && this.board[r * 7 + col] === player; r--) count++;
                for (let r = row + 1; r < 6 && this.board[r * 7 + col] === player; r++) count++;
                if (count >= 4) return true;
                
                // Check diagonal (top-left to bottom-right)
                count = 1;
                for (let r = row - 1, c = col - 1; r >= 0 && c >= 0 && this.board[r * 7 + c] === player; r--, c--) count++;
                for (let r = row + 1, c = col + 1; r < 6 && c < 7 && this.board[r * 7 + c] === player; r++, c++) count++;
                if (count >= 4) return true;
                
                // Check diagonal (top-right to bottom-left)
                count = 1;
                for (let r = row - 1, c = col + 1; r >= 0 && c < 7 && this.board[r * 7 + c] === player; r--, c++) count++;
                for (let r = row + 1, c = col - 1; r < 6 && c >= 0 && this.board[r * 7 + c] === player; r++, c--) count++;
                if (count >= 4) return true;
                
                return false;
            }
            
            checkConnect4Draw() {
                return this.board.every(cell => cell !== '');
            }
            
            
            // Advanced AI using minimax algorithm for hardest difficulty
            getAIMove() {
                switch(this.gameType) {
                    case 'tictactoe':
                        return this.getTicTacToeAIMove();
                    case 'connect4':
                        return this.getConnect4AIMove();
                    case 'numguess':
                        return this.getNumGuessAIMove();
                }
                return -1;
            }
            
            getTicTacToeAIMove() {
                // Minimax algorithm for unbeatable AI
                const minimax = (board, depth, isMaximizing, alpha = -Infinity, beta = Infinity) => {
                    const result = this.evaluateTicTacToeBoard(board);
                    if (result !== null) return result;
                    
                    if (isMaximizing) {
                        let maxEval = -Infinity;
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') {
                                board[i] = 'o';
                                const evalScore = minimax(board, depth + 1, false, alpha, beta);
                                board[i] = '';
                                maxEval = Math.max(maxEval, evalScore);
                                alpha = Math.max(alpha, evalScore);
                                if (beta <= alpha) break;
                            }
                        }
                        return maxEval;
                    } else {
                        let minEval = Infinity;
                        for (let i = 0; i < 9; i++) {
                            if (board[i] === '') {
                                board[i] = 'x';
                                const evalScore = minimax(board, depth + 1, true, alpha, beta);
                                board[i] = '';
                                minEval = Math.min(minEval, evalScore);
                                beta = Math.min(beta, evalScore);
                                if (beta <= alpha) break;
                            }
                        }
                        return minEval;
                    }
                };
                
                let bestMove = -1;
                let bestValue = -Infinity;
                const boardCopy = [...this.board];
                
                for (let i = 0; i < 9; i++) {
                    if (boardCopy[i] === '') {
                        boardCopy[i] = 'o';
                        const moveValue = minimax(boardCopy, 0, false);
                        boardCopy[i] = '';
                        
                        if (moveValue > bestValue) {
                            bestValue = moveValue;
                            bestMove = i;
                        }
                    }
                }
                
                return bestMove;
            }
            
            evaluateTicTacToeBoard(board) {
                const lines = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                
                for (let line of lines) {
                    const [a, b, c] = line;
                    if (board[a] && board[a] === board[b] && board[b] === board[c]) {
                        return board[a] === 'o' ? 10 : -10;
                    }
                }
                
                if (board.every(cell => cell !== '')) return 0;
                return null;
            }
            
            getConnect4AIMove() {
                // Smart Connect 4 AI - prioritize center and look for wins/blocks
                for (let col = 0; col < 7; col++) {
                    if (this.canDropConnect4([...this.board], col)) {
                        const testBoard = this.dropConnect4Piece([...this.board], col, 'o');
                        if (this.checkConnect4WinForBoard(testBoard, this.getDropIndex(col))) {
                            return col; // Winning move
                        }
                    }
                }
                
                // Block opponent wins
                for (let col = 0; col < 7; col++) {
                    if (this.canDropConnect4([...this.board], col)) {
                        const testBoard = this.dropConnect4Piece([...this.board], col, 'x');
                        if (this.checkConnect4WinForBoard(testBoard, this.getDropIndex(col))) {
                            return col; // Block opponent
                        }
                    }
                }
                
                // Prefer center columns
                const priorities = [3, 2, 4, 1, 5, 0, 6];
                for (let col of priorities) {
                    if (this.canDropConnect4([...this.board], col)) {
                        return col;
                    }
                }
                
                return 3; // Fallback
            }
            
            canDropConnect4(board, col) {
                // Check from bottom row (row 5) up to find first empty spot
                for (let row = 5; row >= 0; row--) {
                    const index = row * 7 + col;
                    if (board[index] === '') {
                        return true;
                    }
                }
                return false; // Column is full
            }
            
            dropConnect4Piece(board, col, player) {
                const newBoard = [...board];
                for (let row = 5; row >= 0; row--) {
                    const index = row * 7 + col;
                    if (newBoard[index] === '') {
                        newBoard[index] = player;
                        break;
                    }
                }
                return newBoard;
            }
            
            getDropIndex(col) {
                for (let row = 5; row >= 0; row--) {
                    const index = row * 7 + col;
                    if (this.board[index] === '') {
                        return index;
                    }
                }
                return -1;
            }
            
            checkConnect4WinForBoard(board, lastMoveIndex) {
                const row = Math.floor(lastMoveIndex / 7);
                const col = lastMoveIndex % 7;
                const player = board[lastMoveIndex];

                // Check horizontal (left and right from current position)
                let count = 1;
                // Check left
                for (let c = col - 1; c >= 0; c--) {
                    const index = row * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check right
                for (let c = col + 1; c < 7; c++) {
                    const index = row * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 4) return true;

                // Check vertical (up and down from current position)
                count = 1;
                // Check up
                for (let r = row - 1; r >= 0; r--) {
                    const index = r * 7 + col;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check down
                for (let r = row + 1; r < 6; r++) {
                    const index = r * 7 + col;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 4) return true;

                // Check diagonal (top-left to bottom-right)
                count = 1;
                // Check top-left
                for (let r = row - 1, c = col - 1; r >= 0 && c >= 0; r--, c--) {
                    const index = r * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check bottom-right
                for (let r = row + 1, c = col + 1; r < 6 && c < 7; r++, c++) {
                    const index = r * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 4) return true;

                // Check diagonal (top-right to bottom-left)
                count = 1;
                // Check top-right
                for (let r = row - 1, c = col + 1; r >= 0 && c < 7; r--, c++) {
                    const index = r * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                // Check bottom-left
                for (let r = row + 1, c = col - 1; r < 6 && c >= 0; r++, c--) {
                    const index = r * 7 + c;
                    if (board[index] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                if (count >= 4) return true;

                return false;
            }
            

            
            getNumGuessAIMove() {
                if (this.guesses.length === 0) {
                    return 50;
                }
                
                let min = 1, max = 100;
                
                for (let guess of this.guesses) {
                    if (guess < this.targetNumber) {
                        min = Math.max(min, guess + 1);
                    } else if (guess > this.targetNumber) {
                        max = Math.min(max, guess - 1);
                    }
                }
                
                return Math.floor((min + max) / 2);
            }
            
            // Compact serialization for network messages
            serializeMove(data) {
                return `${this.gameType}:${JSON.stringify(data)}`;
            }
            
            deserializeMove(message) {
                const [gameType, dataStr] = message.split(':');
                if (gameType === this.gameType) {
                    try {
                        return JSON.parse(dataStr);
                    } catch (e) {
                        return parseInt(dataStr); // Fallback for simple numbers
                    }
                }
                return null;
            }
        }
        
        // Memory-optimized app state manager
        class AppState {
            constructor() {
                this.gameEngine = new GameEngine();
                this.currentMode = 'lobby';
                this.selectedGame = 'tictactoe';
                this.roomId = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.signalingServer = null;
                this.isOnline = navigator.onLine;
                this.memoryUpdateInterval = null;
                this.isInitiator = false; // Track if this peer initiated the connection

                // Player names - each player only sets their own name
                this.myName = '';
                this.peerName = '';
                this.myPlayerSymbol = 'x'; // Default, will be set based on connection role

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.startMemoryMonitoring();
                this.updateOnlineStatus();
                this.registerInlineServiceWorker();
            }
            
            setupEventListeners() {
                window.addEventListener('online', () => this.updateOnlineStatus());
                window.addEventListener('offline', () => this.updateOnlineStatus());
                
                // Memory optimization: single event listener for game board
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('cell')) {
                        const index = parseInt(e.target.dataset.index);
                        this.handleCellClick(index);
                    } else if (e.target.classList.contains('connect4-cell')) {
                        const index = parseInt(e.target.dataset.index);
                        const col = parseInt(e.target.dataset.col);

                        // For Connect 4, allow clicks on any clickable cell in a droppable column
                        // The rendering logic ensures only valid cells are clickable
                        if (!e.target.classList.contains('non-clickable')) {
                            const canDrop = this.gameEngine.canDropConnect4(this.gameEngine.board, col);
                            if (canDrop) {
                                this.handleCellClick(index);
                            }
                        }
                    }
                });
            }
            
            startMemoryMonitoring() {
                // Memory optimization: update every 2 seconds instead of every second
                this.memoryUpdateInterval = setInterval(() => {
                    this.updateDebugInfo();
                }, 2000);
            }
            
            updateOnlineStatus() {
                this.isOnline = navigator.onLine;
                this.updateDebugInfo();
                
                if (!this.isOnline && this.currentMode === 'lobby') {
                    this.showOfflineMessage();
                }
            }
            
            showOfflineMessage() {
                const status = document.getElementById('roomStatus');
                if (status) {
                    status.textContent = 'Offline mode - AI and Hotseat available';
                    status.className = 'status offline';
                }
            }
            
            updateDebugInfo() {
                // Memory optimization: only update DOM when values change
                const memoryEl = document.getElementById('memoryUsage');
                const onlineEl = document.getElementById('onlineStatus');
                const peerEl = document.getElementById('peerStatus');
                const gameStateEl = document.getElementById('gameState');
                
                if (memoryEl && performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    memoryEl.textContent = `${memoryMB} MB`;
                }
                
                if (onlineEl) onlineEl.textContent = this.isOnline ? 'true' : 'false';
                if (peerEl) peerEl.textContent = this.dataChannel ? 'connected' : 'none';
                if (gameStateEl) gameStateEl.textContent = this.currentMode;
            }
            
            async registerInlineServiceWorker() {
                // Skip Service Worker registration for file:// protocol
                if (window.location.protocol === 'file:') {
                    return;
                }

                if ('serviceWorker' in navigator) {
                    try {
                        // Create inline service worker using blob URL
                        const serviceWorkerCode = `
                            // Service Worker for Decentralized Game Room - Offline-First Design
                            // Memory optimization: minimal caching strategy, no heavy operations

                            const CACHE_NAME = 'decentralized-game-room-v1';
                            const CACHE_FILES = [
                                '/',
                                '/index.html'
                            ];

                            // Install event - cache essential files
                            self.addEventListener('install', (event) => {
                                event.waitUntil(
                                    caches.open(CACHE_NAME)
                                        .then(cache => {
                                            return cache.addAll(CACHE_FILES);
                                        })
                                        .catch(error => {
                                            console.log('Cache installation failed:', error);
                                        })
                                );
                            });

                            // Activate event - clean up old caches
                            self.addEventListener('activate', (event) => {
                                console.log('Service Worker activating...');
                                event.waitUntil(
                                    caches.keys().then(cacheNames => {
                                        return Promise.all(
                                            cacheNames.map(cacheName => {
                                                if (cacheName !== CACHE_NAME) {
                                                    return caches.delete(cacheName);
                                                }
                                            })
                                        );
                                    })
                                );
                            });

                            // Fetch event - cache-first strategy for app shell
                            self.addEventListener('fetch', (event) => {
                                // Memory optimization: only handle GET requests
                                if (event.request.method !== 'GET') return;

                                // Memory optimization: only cache HTML and JS files
                                const url = new URL(event.request.url);
                                const isAppShell = url.pathname === '/' ||
                                                  url.pathname === '/index.html';

                                if (isAppShell) {
                                    event.respondWith(
                                        caches.match(event.request)
                                            .then(response => {
                                                // Return cached version if available
                                                if (response) {
                                                    return response;
                                                }

                                                // Fetch from network and cache
                                                return fetch(event.request)
                                                    .then(response => {
                                                        // Memory optimization: only cache successful responses
                                                        if (response && response.status === 200) {
                                                            const responseClone = response.clone();
                                                            caches.open(CACHE_NAME)
                                                                .then(cache => {
                                                                    cache.put(event.request, responseClone);
                                                                });
                                                        }
                                                        return response;
                                                    })
                                                    .catch(error => {
                                                        console.log('Network fetch failed:', error);
                                                        // Return cached version if network fails
                                                        return caches.match(event.request);
                                                    });
                                            })
                                    );
                                } else {
                                    // For non-app shell files, try network first, fallback to cache
                                    event.respondWith(
                                        fetch(event.request)
                                            .catch(() => {
                                                return caches.match(event.request);
                                            })
                                    );
                                }
                            });

                            // Memory optimization: handle message events for memory management
                            self.addEventListener('message', (event) => {
                                if (event.data && event.data.type === 'SKIP_WAITING') {
                                    self.skipWaiting();
                                }

                                if (event.data && event.data.type === 'CLEAR_CACHE') {
                                    event.waitUntil(
                                        caches.keys().then(cacheNames => {
                                            return Promise.all(
                                                cacheNames.map(cacheName => caches.delete(cacheName))
                                            );
                                        })
                                    );
                                }
                            });

                            // Connection state management for persistent P2P connections
                            let connectionState = {
                                isConnected: false,
                                peerId: null,
                                lastConnectionTime: null,
                                connectionAttempts: 0
                            };

                            // Handle connection state messages from main thread
                            self.addEventListener('message', (event) => {
                                if (event.data && event.data.type === 'CONNECTION_UPDATE') {
                                    connectionState.isConnected = event.data.isConnected;
                                    connectionState.peerId = event.data.peerId;
                                    connectionState.lastConnectionTime = Date.now();

                                    if (event.data.isConnected) {
                                        connectionState.connectionAttempts = 0;
                                    }

                                    console.log('Connection state updated:', connectionState);
                                }

                                if (event.data && event.data.type === 'CONNECTION_ATTEMPT') {
                                    connectionState.connectionAttempts++;
                                    console.log('Connection attempt logged, total attempts:', connectionState.connectionAttempts);
                                }

                                if (event.data && event.data.type === 'GET_CONNECTION_STATE') {
                                    event.ports[0].postMessage({
                                        type: 'CONNECTION_STATE_RESPONSE',
                                        state: connectionState
                                    });
                                }

                                // Handle existing SKIP_WAITING and CLEAR_CACHE messages
                                if (event.data && event.data.type === 'SKIP_WAITING') {
                                    self.skipWaiting();
                                }

                                if (event.data && event.data.type === 'CLEAR_CACHE') {
                                    event.waitUntil(
                                        caches.keys().then(cacheNames => {
                                            return Promise.all(
                                                cacheNames.map(cacheName => caches.delete(cacheName))
                                            );
                                        })
                                    );
                                }
                            });

                            // Memory optimization: minimal error handling
                            self.addEventListener('error', (event) => {
                                console.log('Service Worker error:', event.error);
                            });

                            // Memory optimization: minimal unhandled rejection handling
                            self.addEventListener('unhandledrejection', (event) => {
                                console.log('Service Worker unhandled rejection:', event.reason);
                            });
                        `;

                        const blob = new Blob([serviceWorkerCode], { type: 'application/javascript' });
                        const serviceWorkerUrl = URL.createObjectURL(blob);

                        const registration = await navigator.serviceWorker.register(serviceWorkerUrl, {
                            scope: './'
                        });


                        // Set up communication with service worker
                        this.setupServiceWorkerCommunication(registration);

                        // Clean up the blob URL after registration
                        URL.revokeObjectURL(serviceWorkerUrl);
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }

            // Set up communication with service worker for connection state management
            setupServiceWorkerCommunication(registration) {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        if (event.data && event.data.type === 'CONNECTION_STATE_RESPONSE') {
                            console.log('Received connection state from SW:', event.data.state);
                        }
                    });
                }
            }

            // Notify service worker of connection state changes
            notifyServiceWorkerConnectionUpdate(isConnected, peerId = null) {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CONNECTION_UPDATE',
                        isConnected: isConnected,
                        peerId: peerId
                    });
                }
            }

            // Notify service worker of connection attempts
            notifyServiceWorkerConnectionAttempt() {
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CONNECTION_ATTEMPT'
                    });
                }
            }

            // Player name management - each player only sets their own name
            setPlayerNames() {
                const myNameInput = document.getElementById('myName');

                if (myNameInput) {
                    const inputValue = myNameInput.value.trim();
                    this.myName = inputValue || 'Player';
                }
            }

            getPlayerName(symbol) {
                if (symbol === this.myPlayerSymbol) {
                    return this.myName;
                } else {
                    return this.peerName;
                }
            }

            getPlayerNameBySymbol(symbol) {
                if (symbol === this.myPlayerSymbol) {
                    return this.myName || `Player ${symbol.toUpperCase()}`;
                } else {
                    return this.peerName || `Player ${symbol.toUpperCase()}`;
                }
            }

            // Disconnect functionality
            disconnectFromPeer() {

                // Send disconnect message to peer before closing connection
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify({
                        type: 'disconnect',
                        timestamp: Date.now()
                    }));

                    // Give the message time to be sent before closing
                    setTimeout(() => {
                        this.completeDisconnect();
                    }, 200);
                } else {
                    // No active data channel, disconnect immediately
                    this.completeDisconnect();
                }
            }

            completeDisconnect() {
                // Notify service worker of disconnection
                this.notifyServiceWorkerConnectionUpdate(false);

                this.cleanupConnection();
                this.currentMode = 'lobby';
                this.isInitiator = false;
                this.myPlayerSymbol = 'x'; // Reset to default

                // Reset player names
                this.myName = '';
                this.peerName = '';

                // Reset UI
                document.getElementById('game').classList.add('hidden');
                document.getElementById('gameMode').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');

                // Hide connection controls
                this.updateConnectionControls(false);

                // Update status
                this.updateRoomStatus('Disconnected', 'info');
                this.updatePeerStatus('disconnected');

            }

            // Handle when peer disconnects
            handlePeerDisconnect() {

                // Show disconnection message to user
                this.showPeerDisconnectedMessage();

                // Since peer has disconnected, we should also disconnect to clean up properly
                // Don't send another disconnect message to avoid infinite loop
                setTimeout(() => {
                    this.forceDisconnect();
                }, 3000); // Give user time to see the message

            }

            // Show message when peer disconnects
            showPeerDisconnectedMessage() {
                // Create a modal overlay for the disconnection message
                const modal = document.createElement('div');
                modal.className = 'modal-overlay active';
                modal.style.zIndex = '2000';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 400px;">
                        <div class="modal-header">
                            <h3 style="color: var(--danger-color);">🔌 Connection Lost</h3>
                        </div>
                        <div class="modal-body" style="text-align: center;">
                            <p style="margin-bottom: 1.5rem; color: var(--text-secondary);">
                                Your peer has disconnected from the game.
                            </p>
                            <p style="color: var(--text-muted); font-size: 0.9rem;">
                                You will be redirected to the home page in a few seconds...
                            </p>
                            <div style="margin-top: 1.5rem;">
                                <button class="btn" onclick="this.closest('.modal-overlay').remove(); appState.forceDisconnect();" style="background: var(--primary-color);">
                                    Go to Home Now
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Auto-remove after 3 seconds and redirect
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.remove();
                    }
                }, 3000);
            }

            // Force disconnect without sending message (used when peer disconnects)
            forceDisconnect() {

                // Notify service worker of disconnection
                this.notifyServiceWorkerConnectionUpdate(false);

                this.cleanupConnection();
                this.currentMode = 'lobby';
                this.isInitiator = false;
                this.myPlayerSymbol = 'x'; // Reset to default

                // Reset player names
                this.myName = '';
                this.peerName = '';

                // Reset UI
                document.getElementById('game').classList.add('hidden');
                document.getElementById('gameMode').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');

                // Hide connection controls
                this.updateConnectionControls(false);

                // Update status with warning
                this.updateRoomStatus('Peer has disconnected - connection closed', 'warning');
                this.updatePeerStatus('disconnected');

                // Show a message to the user
                setTimeout(() => {
                    alert('Your peer has disconnected. The connection has been closed.');
                }, 100);

            }

            // Update connection controls visibility and player names
            updateConnectionControls(show) {
                const controlsEl = document.getElementById('connectionControls');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const playerNamesEl = document.getElementById('playerNamesDisplay');

                // Update game view controls
                if (show && this.currentMode === 'network') {
                    if (controlsEl) controlsEl.style.display = 'flex';
                    if (disconnectBtn) disconnectBtn.style.display = 'inline-block';
                    if (playerNamesEl) playerNamesEl.style.display = 'block';

                    // Update player names display - show actual names based on symbols
                    const player1El = document.getElementById('player1Display');
                    const player2El = document.getElementById('player2Display');

                    if (player1El && player2El) {
                        // Display names correctly: X player vs O player
                        const xName = this.getPlayerNameBySymbol('x') || 'Player X';
                        const oName = this.getPlayerNameBySymbol('o') || 'Player O';
                        player1El.textContent = xName;
                        player2El.textContent = oName;
                    }
                } else {
                    if (controlsEl) controlsEl.style.display = 'none';
                    if (disconnectBtn) disconnectBtn.style.display = 'none';
                    if (playerNamesEl) playerNamesEl.style.display = 'none';
                }

                // Update lobby connection status
                this.updateLobbyConnectionStatus();
            }

            // Update lobby connection status indicator
            updateLobbyConnectionStatus() {
                const lobbyStatusEl = document.getElementById('lobbyConnectionStatus');
                const lobbyPeerNameEl = document.getElementById('lobbyPeerName');
                const roomSelectionEl = document.querySelector('.room-selection');

                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    // Show connection status in lobby
                    if (lobbyStatusEl) lobbyStatusEl.classList.remove('hidden');
                    if (lobbyPeerNameEl) {
                        // Show the peer's name
                        const peerSymbol = this.myPlayerSymbol === 'x' ? 'o' : 'x';
                        const peerName = this.peerName || `Player ${peerSymbol.toUpperCase()}`;
                        lobbyPeerNameEl.textContent = peerName;
                    }
                    // Hide room creation buttons since we're already connected
                    if (roomSelectionEl) roomSelectionEl.style.display = 'none';
                } else {
                    // Hide connection status in lobby
                    if (lobbyStatusEl) lobbyStatusEl.classList.add('hidden');
                    // Show room creation buttons since we're not connected
                    if (roomSelectionEl) roomSelectionEl.style.display = 'block';
                }
            }
            
            // Game selection
            selectGame(gameType) {
                this.selectedGame = gameType;
                this.gameEngine.setGameType(gameType);

                // If we have an active P2P connection, start the game directly
                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.currentMode = 'network';
                    this.gameEngine.reset();

                    // Notify the peer to start the same game
                    this.dataChannel.send(JSON.stringify({
                        type: 'game_selected',
                        gameType: gameType,
                        timestamp: Date.now()
                    }));

                    this.showGame();
                    return;
                }

                // Otherwise, show the game mode selection (Create Room/Join Room/etc)
                this.showGameModeSelection();
            }
            
            showGameModeSelection() {
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('gameMode').classList.remove('hidden');
                
                const gameNames = {
                    'tictactoe': '🎯 Tic-Tac-Toe',
                    'connect4': '🔴 Connect Four', 
                    'rps': '✂️ Rock Paper Scissors',
                    'numguess': '🔢 Number Guessing'
                };
                
                document.getElementById('selectedGameTitle').textContent = gameNames[this.selectedGame];
            }
            
            backToGameSelection() {
                this.currentMode = 'lobby';
                this.gameEngine.reset();

                // Don't cleanup connection - keep it persistent for multiple games
                // this.cleanupConnection(); // Commented out to maintain persistent connection

                // Notify peer to go back to game selection
                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify({
                        type: 'back_to_games',
                        timestamp: Date.now()
                    }));
                }

                document.getElementById('game').classList.add('hidden');
                document.getElementById('gameMode').classList.add('hidden');
                this.closeHandshakeModal();
                document.getElementById('lobby').classList.remove('hidden');

                // Update connection controls - keep them visible if connected
                this.updateConnectionControls(this.currentMode === 'network');
            }

            // Game mode handlers
            createRoom() {
                // Check if we already have an active connection
                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.currentMode = 'network';
                    this.isInitiator = true;
                    this.gameEngine.reset();
                    this.showGame();
                    return;
                }

                this.currentMode = 'manual';
                this.isInitiator = true;

                // Go directly to manual handshake
                this.startManualHandshake();
            }

            joinRoom() {
                // Check if we already have an active connection
                if (this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.currentMode = 'network';
                    this.isInitiator = false;
                    this.gameEngine.reset();
                    this.showGame();
                    return;
                }

                this.showJoinModal();
            }
            
            playVsAI() {
                this.currentMode = 'ai';
                this.gameEngine.reset();
                this.showGame();
            }
            
            playHotseat() {
                this.currentMode = 'hotseat';
                this.gameEngine.reset();
                this.showGame();
            }
            
            
            
            showGame() {
                // Ensure proper UI state transition
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('gameMode').classList.add('hidden');
                document.getElementById('game').classList.remove('hidden');

                this.renderGameBoard();
                this.updateGameStatus();

                // Show connection controls if in network mode
                this.updateConnectionControls(this.currentMode === 'network');
            }
            
            backToLobby() {
                this.currentMode = 'lobby';
                this.gameEngine.reset();

                // Don't cleanup connection - keep it persistent for multiple games
                // this.cleanupConnection(); // Commented out to maintain persistent connection

                this.isInitiator = false;
                document.getElementById('game').classList.add('hidden');
                document.getElementById('roomInfo').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');

                // Keep connection controls visible if still connected
                this.updateConnectionControls(this.peerConnection && this.dataChannel && this.dataChannel.readyState === 'open');
            }
            
            showJoinModal() {
                // Directly start manual handshake instead of showing join modal
                this.startManualHandshake();
            }
            
            closeJoinModal() {
                // This method is kept for compatibility but does nothing
                // since we removed the join modal
            }
            
            async connectToRoom() {
                this.currentMode = 'manual';
                this.isInitiator = false;
                this.closeJoinModal();
                
                // Go directly to manual handshake
                this.startManualHandshake();
            }
            
            
            // WebRTC and signaling
            async connectToSignalingServer() {
                try {

                    // Notify service worker of connection attempt
                    this.notifyServiceWorkerConnectionAttempt();

                    this.signalingServer = new WebSocket('ws://localhost:8080');
                    
                    this.signalingServer.onopen = () => {
                        if (this.isInitiator) {
                            // Create room on server
                            this.signalingServer.send(JSON.stringify({
                                t: 'create',
                                room: this.roomId
                            }));
                        } else {
                            // Join room on server
                            this.signalingServer.send(JSON.stringify({
                                t: 'join',
                                room: this.roomId
                            }));
                        }
                    };
                    
                    this.signalingServer.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.handleSignalingMessage(message);
                    };
                    
                    this.signalingServer.onerror = () => {
                        this.handleSignalingError();
                    };
                    
                    this.signalingServer.onclose = () => {
                        this.handleSignalingError();
                    };
                    
                    // Memory optimization: timeout for signaling
                    setTimeout(() => {
                        if (!this.dataChannel) {
                            this.handleSignalingError();
                        }
                    }, 10000);
                    
                } catch (error) {
                    this.handleSignalingError();
                }
            }
            
            handleSignalingMessage(message) {
                switch (message.t) {
                    case 'created':
                        this.updateRoomStatus('Room created on server. Waiting for peer...', 'waiting');
                        break;
                    case 'peer_joined':
                        this.updateRoomStatus('Peer joined! Establishing connection...', 'info');
                        if (this.isInitiator) {
                            this.createPeerConnection();
                        }
                        break;
                    case 'offer':
                        this.handleOffer(message.offer);
                        break;
                    case 'answer':
                        this.handleAnswer(message.answer);
                        break;
                    case 'ice':
                        this.handleIceCandidate(message.cand);
                        break;
                    default:
                        console.log('Unknown message type:', message.t);
                }
            }
            
            async createPeerConnection() {
                try {
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.signalingServer) {
                            this.signalingServer.send(JSON.stringify({
                                t: 'ice',
                                room: this.roomId,
                                cand: event.candidate
                            }));
                        }
                    };
                    
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    if (this.signalingServer) {
                        this.signalingServer.send(JSON.stringify({
                            t: 'offer',
                            room: this.roomId,
                            offer: offer
                        }));
                    }
                    
                } catch (error) {
                    this.handleSignalingError();
                }
            }
            
            async handleOffer(offer) {
                try {
                    if (!this.peerConnection) {
                        this.peerConnection = new RTCPeerConnection({
                            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                        });
                        
                        this.peerConnection.ondatachannel = (event) => {
                            this.setupDataChannel(event.channel);
                        };
                        
                        this.peerConnection.onicecandidate = (event) => {
                            if (event.candidate && this.signalingServer) {
                                this.signalingServer.send(JSON.stringify({
                                    t: 'ice',
                                    room: this.roomId,
                                    cand: event.candidate
                                }));
                            }
                        };
                    }
                    
                    await this.peerConnection.setRemoteDescription(offer);
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    if (this.signalingServer) {
                        this.signalingServer.send(JSON.stringify({
                            t: 'answer',
                            room: this.roomId,
                            answer: answer
                        }));
                    }
                    
                } catch (error) {
                    this.handleSignalingError();
                }
            }
            
            async handleAnswer(answer) {
                try { 
                    // Validate answer format
                    if (!answer || typeof answer !== 'object') {
                        console.error('Answer is not a valid object:', answer);
                        throw new Error('Invalid answer format - not an object');
                    }
                    
                    if (!answer.sdp || typeof answer.sdp !== 'string') {
                        console.error('Answer missing or invalid SDP:', answer.sdp);
                        throw new Error('Invalid answer format - missing SDP');
                    }
                    
                    // Accept any type that looks like an answer
                    if (answer.type && answer.type !== 'answer') {
                        console.error('Answer has wrong type:', answer.type);
                        throw new Error('Invalid answer format - wrong type');
                    }
                    
                    // If no type is specified, assume it's an answer
                    if (!answer.type) {
                        answer.type = 'answer';
                    }
                    
                    await this.peerConnection.setRemoteDescription(answer);
                } catch (error) {
                    console.error('Error handling answer:', error);
                    throw error; // Re-throw to be caught by the calling function
                }
            }
            
            handleIceCandidate(candidate) {
                if (this.peerConnection) {
                    this.peerConnection.addIceCandidate(candidate);
                }
            }
            
            setupDataChannel(channel) {
                this.dataChannel = channel;
                console.log('Setting up data channel, current state:', channel.readyState);
                console.log('Data channel label:', channel.label);
                console.log('Data channel id:', channel.id);
                
                this.dataChannel.onopen = () => {
                    console.log('=== DATA CHANNEL OPENED ===');
                    console.log('Channel state:', this.dataChannel.readyState);
                    console.log('Channel label:', this.dataChannel.label);
                    console.log('Channel id:', this.dataChannel.id);
                    
                    this.updatePeerStatus('connected');

                    // Notify service worker of connection
                    this.notifyServiceWorkerConnectionUpdate(true, this.peerName);

                    // Set network mode and show game for both sender and receiver
                    this.currentMode = 'network';
                    this.gameEngine.reset();

                    // Capture player name from input field right before sending
                    this.setPlayerNames();

                    // Assign player symbols based on who initiated the connection
                    // If we have a data channel that we created, we're the host (X)
                    // If we received a data channel, we're the joiner (O)
                    if (this.peerConnection && this.peerConnection.localDescription && this.peerConnection.localDescription.type === 'offer') {
                        // We created the offer, so we're the host (X)
                        this.myPlayerSymbol = 'x';
                        console.log('I am the host (created offer), playing as X');

                        // Send our player name to the peer immediately
                        this.dataChannel.send(JSON.stringify({
                            type: 'player_info',
                            name: this.myName,
                            symbol: 'x'
                        }));
                    } else {
                        // We received the offer and created the answer, so we're the joiner (O)
                        this.myPlayerSymbol = 'o';
                        console.log('I am the joiner (created answer), playing as O');

                        // Send our player name to the peer immediately
                        this.dataChannel.send(JSON.stringify({
                            type: 'player_info',
                            name: this.myName,
                            symbol: 'o'
                        }));
                    }

                    // Close any open modals and show game
                    this.closeHandshakeModal();
                    this.showGame();
                    this.renderGameBoard();
                    
                    console.log('=== GAME VIEW SHOULD BE VISIBLE NOW ===');
                    console.log('Current mode:', this.currentMode);
                    console.log('My player symbol:', this.myPlayerSymbol);
                    console.log('My name:', this.myName);
                };
                
                this.dataChannel.onerror = (error) => {
                    console.error('Data channel error:', error);
                };
                
                this.dataChannel.onclose = () => {
                    console.log('Data channel closed');
                };
                
                this.dataChannel.onmessage = (event) => {

                    try {
                        const message = JSON.parse(event.data);

                        // Handle player info exchange
                        if (message.type === 'player_info') {
                            
                            // Store the peer's name (the one that doesn't match our symbol)
                            if (message.symbol !== this.myPlayerSymbol) {
                                this.peerName = message.name;
                            } else {
                                // This is our own name being echoed back, update if needed
                                this.myName = message.name;
                            }

                            // Update the display with received player names
                            this.updateConnectionControls(true);
                            return;
                        }

                        // Handle rematch signal
                        if (message.type === 'rematch') {
                            this.gameEngine.reset();
                            const gameOverActionsEl = document.getElementById('gameOverActions');
                            if (gameOverActionsEl) {
                                gameOverActionsEl.classList.add('hidden');
                            }
                            this.renderGameBoard();
                            this.updateGameStatus();
                            return;
                        }

                        // Handle disconnect signal
                        if (message.type === 'disconnect') {
                            this.handlePeerDisconnect();
                            return;
                        }

                        // Handle game selection from peer
                        if (message.type === 'game_selected') {
                            this.selectedGame = message.gameType;
                            this.gameEngine.setGameType(message.gameType);
                            this.currentMode = 'network';
                            this.gameEngine.reset();
                            this.showGame();
                            return;
                        }

                        // Handle peer going back to game selection
                        if (message.type === 'back_to_games') {
                            this.currentMode = 'lobby';
                            this.gameEngine.reset();
                            document.getElementById('game').classList.add('hidden');
                            document.getElementById('gameMode').classList.add('hidden');
                            document.getElementById('lobby').classList.remove('hidden');
                            this.updateConnectionControls(this.currentMode === 'network');
                            return;
                        }
                    } catch (e) {
                        // Not a JSON message, handle as legacy format
                    }

                    // Handle game moves (legacy format)
                    const move = this.gameEngine.deserializeMove(event.data);
                    if (move !== -1) {
                        this.gameEngine.makeMove(move);
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                };
                
                this.dataChannel.onclose = () => {
                    console.log('Data channel closed');
                    // Only treat as peer disconnection if connection is actually established
                    if (this.peerConnection) {
                        if (this.peerConnection.connectionState === 'connected' ||
                            this.peerConnection.iceConnectionState === 'connected') {
                            console.log('Data channel closed while connection was active - peer disconnected');
                            this.updatePeerStatus('disconnected');
                            this.handlePeerDisconnect();
                        } else {
                            console.log('Data channel closed during connection setup - this is normal');
                        }
                    }
                };
            }
            
            handleSignalingError() {
                this.updateRoomStatus('Signaling server unavailable. Use manual handshake below.', 'error');
            }
            
            updatePeerStatus(status) {
                const statusEl = document.getElementById('peerStatus');
                if (statusEl) {
                    statusEl.textContent = status;
                }
            }

            updateRoomStatus(message, type = 'info') {
                // Try to find an appropriate status element to update
                let statusEl = document.getElementById('gameStatus');
                if (!statusEl) {
                    statusEl = document.getElementById('peerStatus');
                }
                if (!statusEl) {
                    // If no status element found, try to create a temporary one or use console
                    console.log('Room status:', message, type);
                    return;
                }

                if (statusEl) {
                    statusEl.textContent = message;
                    // Update class based on type
                    statusEl.className = `status ${type}`;
                }
            }
            
            // Manual handshake methods
            startManualHandshake() {
                this.resetHandshakeModal();
                this.clearHandshakeInputs();
                this.setPlayerNames(); // Capture player names before starting connection
                const modal = document.getElementById('handshakeModal');
                modal.classList.add('active');

                // Close modal when clicking on overlay
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeHandshakeModal();
                    }
                });

                // Close modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        this.closeHandshakeModal();
                    }
                });
            }
            
            closeHandshakeModal() {
                const modal = document.getElementById('handshakeModal');
                modal.classList.remove('active');
            }
            
            async processManualAnswer() {
                const answerText = document.getElementById('answerInput').value.trim();
                if (!answerText) return;
                
                try {
                    const answer = JSON.parse(answerText);
                    await this.handleAnswer(answer);
                    this.closeHandshakeModal();
                } catch (error) {
                    console.log('Error processing manual answer:', error);
                    alert('Invalid answer format. Please check the peer\'s answer.');
                }
            }
            
            // Game rendering and interaction
            renderGameBoard() {
                // Hide all game boards first
                document.getElementById('tictactoeBoard').classList.add('hidden');
                document.getElementById('connect4Board').classList.add('hidden');
                document.getElementById('numguessControls').classList.add('hidden');
                
                // Update game title
                const gameNames = {
                    'tictactoe': '🎯 Tic-Tac-Toe',
                    'connect4': '🔴 Connect Four', 
                    'rps': '✂️ Rock Paper Scissors',
                    'numguess': '🔢 Number Guessing'
                };
                document.getElementById('gameTitle').textContent = gameNames[this.selectedGame];
                
                // Show and render the appropriate game board
                switch(this.selectedGame) {
                    case 'tictactoe':
                        this.renderTicTacToeBoard();
                        break;
                    case 'connect4':
                        this.renderConnect4Board();
                        break;
                    case 'numguess':
                        this.renderNumGuessBoard();
                        break;
                }
                
                this.updateScoreDisplay();
            }

            updateScoreDisplay() {
                const score = this.gameEngine.score;
                let scoreDisplay = document.getElementById('scoreDisplay');
                let scoreText = '';

                if (this.gameEngine.gameType === 'numguess') {
                    scoreText = `Your Score: ${score.x} | Opponent Score: ${score.o}`;
                } else {
                    const xName = this.getPlayerNameBySymbol('x') || 'Player X';
                    const oName = this.getPlayerNameBySymbol('o') || 'Player O';
                    scoreText = `${xName}: ${score.x} | ${oName}: ${score.o} | Draws: ${score.draws}`;
                }

                if (scoreDisplay) {
                    scoreDisplay.textContent = scoreText;
                }
            }
            
            renderTicTacToeBoard() {
                const board = document.getElementById('tictactoeBoard');
                board.classList.remove('hidden');
                board.innerHTML = '';
                
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    
                    if (this.gameEngine.board[i] === 'x') {
                        cell.textContent = 'X';
                        cell.classList.add('x');
                    } else if (this.gameEngine.board[i] === 'o') {
                        cell.textContent = 'O';
                        cell.classList.add('o');
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            renderConnect4Board() {
                const board = document.getElementById('connect4Board');
                board.classList.remove('hidden');
                board.innerHTML = '';

                for (let i = 0; i < 42; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'connect4-cell';
                    cell.dataset.index = i;
                    cell.dataset.col = i % 7;

                    const row = Math.floor(i / 7);
                    const col = i % 7;

                    // Only allow clicking on cells that can actually receive pieces
                    // For Connect 4, pieces fall to the bottom, so only the bottom-most empty cell in each droppable column is clickable
                    if (this.gameEngine.board[i] !== '') {
                        // Cell is already occupied
                        cell.classList.add('non-clickable');
                    } else {
                        // Cell is empty - check if column is droppable and if this is the bottom-most empty cell
                        if (!this.gameEngine.canDropConnect4([...this.gameEngine.board], col)) {
                            // Column is full
                            cell.classList.add('non-clickable');
                        } else {
                            // Column is droppable - check if this is the cell that will receive the piece
                            // (the bottom-most empty cell in the column)
                            let isBottomMostEmpty = true;
                            for (let r = row + 1; r < 6; r++) {
                                const belowIndex = r * 7 + col;
                                if (this.gameEngine.board[belowIndex] === '') {
                                    isBottomMostEmpty = false;
                                    break;
                                }
                            }
                            if (!isBottomMostEmpty) {
                                cell.classList.add('non-clickable');
                            }
                        }
                    }

                    if (this.gameEngine.board[i] === 'x') {
                        cell.classList.add('red');
                    } else if (this.gameEngine.board[i] === 'o') {
                        cell.classList.add('yellow');
                    }

                    board.appendChild(cell);
                }
            }
            
            renderNumGuessBoard() {
                const controls = document.getElementById('numguessControls');
                controls.classList.remove('hidden');
                
                document.getElementById('numguessInfo').textContent = 
                    this.gameEngine.gameOver ? 
                    `The number was ${this.gameEngine.targetNumber}!` :
                    `Guess a number between 1 and 100! (${this.gameEngine.maxAttempts - this.gameEngine.attempts} attempts left)`;
                    
                document.getElementById('numguessAttempts').textContent = 
                    `Attempts: ${this.gameEngine.attempts}`;
            }
            
            // Game-specific move handlers
            handleCellClick(index) {
                let moveData;

                if (this.selectedGame === 'connect4') {
                    // For Connect 4, we always pass the column number as moveData
                    // regardless of which row the player clicked on
                    const col = index % 7;
                    moveData = col;
                } else {
                    moveData = index;
                }
                
                // AI mode: player vs AI
                if (this.currentMode === 'ai' && this.gameEngine.currentPlayer === 'x') {
                    if (this.gameEngine.makeMove(moveData)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                        
                        // AI move after a short delay
                        setTimeout(() => {
                            if (!this.gameEngine.gameOver) {
                                const aiMove = this.gameEngine.getAIMove();
                                if (aiMove !== -1) {
                                    this.gameEngine.makeMove(aiMove);
                                    this.renderGameBoard();
                                    this.updateGameStatus();
                                }
                            }
                        }, 500);
                    }
                }
                // Hotseat mode: alternating players
                else if (this.currentMode === 'hotseat') {
                    if (this.gameEngine.makeMove(moveData)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                }
                // Network mode: only current player can move
                else if (this.currentMode === 'network' && this.dataChannel && this.dataChannel.readyState === 'open') {
                    // Check if it's this player's turn
                    if (this.gameEngine.currentPlayer === this.myPlayerSymbol) {
                        const moveMessage = this.gameEngine.serializeMove(moveData);
                        this.dataChannel.send(moveMessage);
                        
                        if (this.gameEngine.makeMove(moveData)) {
                            this.renderGameBoard();
                            this.updateGameStatus();
                        }
                    }
                }
            }
            
            makeNumGuess() {
                const input = document.getElementById('numguessInput');
                const guess = parseInt(input.value);
                
                if (isNaN(guess) || guess < 1 || guess > 100) {
                    alert('Please enter a number between 1 and 100');
                    return;
                }
                
                input.value = '';
                
                if (this.currentMode === 'ai') {
                    if (this.gameEngine.makeMove(guess)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                } else if (this.currentMode === 'hotseat') {
                    if (this.gameEngine.makeMove(guess)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                } else if (this.currentMode === 'network' && this.dataChannel && this.dataChannel.readyState === 'open') {
                    if (this.gameEngine.currentPlayer === this.myPlayerSymbol) {
                        const moveMessage = this.gameEngine.serializeMove(guess);
                        this.dataChannel.send(moveMessage);
                        
                        if (this.gameEngine.makeMove(guess)) {
                            this.renderGameBoard();
                            this.updateGameStatus();
                        }
                    }
                }
            }
            
            updateGameStatus() {
                const statusEl = document.getElementById('gameStatus');
                const gameOverActionsEl = document.getElementById('gameOverActions');
                if (!statusEl) return;
                
                if (this.gameEngine.gameOver) {
                    if (this.gameEngine.winner === 'draw') {
                        statusEl.textContent = "It's a draw!";
                        statusEl.className = 'status';
                    } else {
                        statusEl.textContent = `Player ${this.gameEngine.winner.toUpperCase()} wins!`;
                        statusEl.className = 'status connected';
                    }
                    
                    // Show game over actions
                    if (gameOverActionsEl) {
                        gameOverActionsEl.classList.remove('hidden');
                    }
                } else {
                    const currentPlayerName = this.getPlayerNameBySymbol(this.gameEngine.currentPlayer) || `Player ${this.gameEngine.currentPlayer.toUpperCase()}`;
                    statusEl.textContent = `${currentPlayerName}'s turn`;
                    statusEl.className = 'status';
                    
                    // Hide game over actions
                    if (gameOverActionsEl) {
                        gameOverActionsEl.classList.add('hidden');
                    }
                }
            }
            
            rematchGame() {
                // Reset game engine
                this.gameEngine.reset();
                
                // Hide game over actions
                const gameOverActionsEl = document.getElementById('gameOverActions');
                if (gameOverActionsEl) {
                    gameOverActionsEl.classList.add('hidden');
                }
                
                // Re-render board and update status
                this.renderGameBoard();
                this.updateGameStatus();
                
                // If in network mode, send rematch signal to peer
                if (this.currentMode === 'network' && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send('rematch');
                }
            }
            
            cleanupConnection() {
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                if (this.signalingServer) {
                    this.signalingServer.close();
                    this.signalingServer = null;
                }
            }
            
            // New methods for manual handshake functionality
            openManualJoin() {
                this.closeJoinModal();
                document.getElementById('handshakeModal').classList.remove('hidden');
                this.clearHandshakeInputs();
                // Skip mode selection and go directly to join mode
                this.startJoinMode();
            }
            
            resetHandshakeModal() {
                document.getElementById('modeSelection').classList.remove('hidden');
                document.getElementById('createMode').classList.add('hidden');
                document.getElementById('joinMode').classList.add('hidden');
                document.getElementById('generatedAnswerSection').classList.add('hidden');
                this.hideLoaders();
            }
            
            clearHandshakeInputs() {
                document.getElementById('offerText').value = '';
                document.getElementById('answerInput').value = '';
                document.getElementById('receivedOfferInput').value = '';
                document.getElementById('answerText').value = '';
                document.getElementById('myName').value = '';
            }
            
            hideLoaders() {
                document.getElementById('createLoader').classList.add('hidden');
                document.getElementById('answerLoader').classList.add('hidden');
            }
            
            showLoader(loaderId) {
                document.getElementById(loaderId).classList.remove('hidden');
            }
            
            startCreateMode() {
                document.getElementById('modeSelection').classList.add('hidden');
                document.getElementById('createMode').classList.remove('hidden');
                document.getElementById('joinMode').classList.add('hidden');
                
                // Show loader and generate offer
                this.showLoader('createLoader');
                this.generateOffer();
            }
            
            startJoinMode() {
                document.getElementById('modeSelection').classList.add('hidden');
                document.getElementById('createMode').classList.add('hidden');
                document.getElementById('joinMode').classList.remove('hidden');
                document.getElementById('generatedAnswerSection').classList.add('hidden');
            }
            
            async generateOffer() {
                try {
                    
                    // Create completely new peer connection with multiple STUN servers
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ],
                        iceCandidatePoolSize: 10
                    });
                    
                    // Set up ICE candidate gathering
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log('ICE candidate generated:', event.candidate.type, event.candidate.candidate);
                        } else {
                            console.log('ICE candidate gathering complete');
                        }
                    };

                    // Add ICE connection state monitoring for better debugging
                    pc.oniceconnectionstatechange = () => {
                        console.log('ICE connection state:', pc.iceConnectionState);
                    };

                    // Add ICE gathering state monitoring
                    pc.onicegatheringstatechange = () => {
                        console.log('ICE gathering state:', pc.iceGatheringState);
                    };

                    pc.onconnectionstatechange = () => {
                        console.log('Connection state changed:', pc.connectionState);
                        console.log('ICE connection state:', pc.iceConnectionState);
                        console.log('Signaling state:', pc.signalingState);
                        
                        // Only handle disconnection if we're connected and have a data channel
                        if (this.dataChannel && this.dataChannel.readyState === 'open') {
                            if (pc.connectionState === 'failed' ||
                                (pc.connectionState === 'closed' && pc.iceConnectionState !== 'checking')) {
                                console.log('Peer connection failed after being established');
                                this.handlePeerDisconnect();
                            }
                            // For 'disconnected' state, wait a bit before declaring it a failure
                            else if (pc.connectionState === 'disconnected') {
                                console.log('Peer temporarily disconnected, waiting for reconnection...');
                                setTimeout(() => {
                                    if (pc && pc.connectionState === 'disconnected') {
                                        console.log('Peer connection lost');
                                        this.handlePeerDisconnect();
                                    }
                                }, 5000); // Wait 5 seconds before giving up
                            }
                        }
                    };
                    
                    // Create data channel with proper configuration
                    const dc = pc.createDataChannel('gameData', {
                        ordered: true,
                        maxRetransmits: 3
                    });
                    console.log('Data channel created with label:', dc.label);
                    
                    // Create offer and wait for ICE gathering
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // Wait for ICE gathering to complete (with longer timeout for better connectivity)
                    await Promise.race([
                        new Promise((resolve) => {
                            if (pc.iceGatheringState === 'complete') {
                                console.log('ICE gathering already complete');
                                resolve();
                            } else {
                                console.log('Waiting for ICE gathering to complete...');
                                pc.addEventListener('icegatheringstatechange', () => {
                                    console.log('ICE gathering state changed to:', pc.iceGatheringState);
                                    if (pc.iceGatheringState === 'complete') {
                                        console.log('ICE gathering completed');
                                        resolve();
                                    }
                                });
                            }
                        }),
                        new Promise((resolve) => {
                            console.log('ICE gathering timeout after 5 seconds');
                            setTimeout(resolve, 5000); // Increased to 5 seconds for better connectivity
                        })
                    ]);
                    
                    // Only assign to instance variables after successful creation
                    this.peerConnection = pc;
                    this.dataChannel = dc;
                    this.setupDataChannel(dc);
                    
                    // Display complete offer with ICE candidates (encoded for shorter strings)
                    const completeOffer = pc.localDescription;
                    console.log('Complete offer object:', completeOffer);
                    console.log('Offer type:', completeOffer.type);
                    console.log('Offer SDP length:', completeOffer.sdp.length);
                    
                    const encodedOffer = encodeSDP(completeOffer);
                    if (!encodedOffer) {
                        throw new Error('Failed to encode offer');
                    }
                    
                    console.log('Encoded offer length:', encodedOffer.length);
                    document.getElementById('offerText').value = encodedOffer;
                    
                    // Hide loader
                    this.hideLoaders();
                    
                } catch (error) {
                    console.error('Error generating offer:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);

                    // Provide more specific error messages
                    let errorMessage = 'Failed to generate offer. ';
                    if (error.message.includes('RTCPeerConnection')) {
                        errorMessage += 'WebRTC is not supported or permissions are blocked.';
                    } else if (error.message.includes('network') || error.message.includes('ICE')) {
                        errorMessage += 'Network connectivity issue. Check your internet connection.';
                    } else if (error.message.includes('permission') || error.message.includes('denied')) {
                        errorMessage += 'Browser permissions are required for WebRTC. Please allow camera/microphone access.';
                    } else {
                        errorMessage += 'Please check your browser settings and try again.';
                    }

                    alert(errorMessage);
                    this.hideLoaders();
                }
            }
            
            async processReceivedOffer() {
                const offerText = document.getElementById('receivedOfferInput').value.trim();
                if (!offerText) {
                    alert('Please paste the offer you received.');
                    return;
                }
                
                // Show loader
                this.showLoader('answerLoader');
                
                try {

                    // Decode the compressed offer
                    const decodedOffer = decodeSDP(offerText);

                    if (!decodedOffer) {
                        console.error('decodeSDP returned null/undefined');
                        throw new Error('Failed to decode offer - invalid format');
                    }

                    const offer = decodedOffer;

                    if (offer.type !== 'offer' || !offer.sdp) {
                        console.error('Offer validation failed:', {
                            type: offer.type,
                            hasSDP: !!offer.sdp,
                            sdpLength: offer.sdp ? offer.sdp.length : 0
                        });
                        throw new Error('Invalid offer format');
                    }
                    
                    // Clean up any existing connection
                    if (this.peerConnection) {
                        this.peerConnection.close();
                        this.peerConnection = null;
                    }
                    if (this.dataChannel) {
                        this.dataChannel.close();
                        this.dataChannel = null;
                    }
                    
                    // Create fresh peer connection for receiver with multiple STUN servers
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            { urls: 'stun:stun3.l.google.com:19302' },
                            { urls: 'stun:stun4.l.google.com:19302' }
                        ],
                        iceCandidatePoolSize: 10
                    });

                    // Add ICE connection state monitoring for better debugging
                    this.peerConnection.oniceconnectionstatechange = () => {
                        console.log('ICE connection state:', this.peerConnection.iceConnectionState);
                    };

                    // Add ICE gathering state monitoring
                    this.peerConnection.onicegatheringstatechange = () => {
                        console.log('ICE gathering state:', this.peerConnection.iceGatheringState);
                    };
                    
                    // Add ICE candidate handling
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log('Answer ICE candidate generated:', event.candidate.type, event.candidate.candidate);
                        } else {
                            console.log('Answer ICE candidate gathering complete');
                        }
                    };
                    
                    // Set up connection state monitoring
                    this.peerConnection.onconnectionstatechange = () => {
                        console.log('Connection state changed:', this.peerConnection.connectionState);
                        console.log('ICE connection state:', this.peerConnection.iceConnectionState);
                        console.log('Signaling state:', this.peerConnection.signalingState);
                        
                        // Only handle disconnection if we're connected and have a data channel
                        if (this.dataChannel && this.dataChannel.readyState === 'open') {
                            if (this.peerConnection.connectionState === 'failed' ||
                                (this.peerConnection.connectionState === 'closed' && this.peerConnection.iceConnectionState !== 'checking')) {
                                console.log('Peer connection failed after being established');
                                this.handlePeerDisconnect();
                            }
                            // For 'disconnected' state, wait a bit before declaring it a failure
                            else if (this.peerConnection.connectionState === 'disconnected') {
                                console.log('Peer temporarily disconnected, waiting for reconnection...');
                                setTimeout(() => {
                                    if (this.peerConnection && this.peerConnection.connectionState === 'disconnected') {
                                        console.log('Peer connection lost');
                                        this.handlePeerDisconnect();
                                    }
                                }, 5000); // Wait 5 seconds before giving up
                            }
                        }
                    };
                    
                    await this.peerConnection.setRemoteDescription(offer);
                    
                    // Create answer
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    // Wait for ICE gathering to complete (with longer timeout for better connectivity)
                    await Promise.race([
                        new Promise((resolve) => {
                            if (this.peerConnection.iceGatheringState === 'complete') {
                                console.log('Answer ICE gathering already complete');
                                resolve();
                            } else {
                                console.log('Waiting for answer ICE gathering to complete...');
                                this.peerConnection.addEventListener('icegatheringstatechange', () => {
                                    console.log('Answer ICE gathering state changed to:', this.peerConnection.iceGatheringState);
                                    if (this.peerConnection.iceGatheringState === 'complete') {
                                        console.log('Answer ICE gathering completed');
                                        resolve();
                                    }
                                });
                            }
                        }),
                        new Promise((resolve) => {
                            console.log('Answer ICE gathering timeout after 5 seconds');
                            setTimeout(resolve, 5000); // Increased to 5 seconds for better connectivity
                        })
                    ]);
                    
                    // Display the complete answer with ICE candidates (encoded for shorter strings)
                    const completeAnswer = this.peerConnection.localDescription;
                    const encodedAnswer = encodeSDP(completeAnswer);
                    document.getElementById('answerText').value = encodedAnswer;
                    document.getElementById('generatedAnswerSection').classList.remove('hidden');
                    
                    // Set up data channel handling for receiver
                    this.peerConnection.ondatachannel = (event) => {
                        this.setupDataChannel(event.channel);
                    };
                    
                    
                    // Hide loader
                    this.hideLoaders();
                    
                } catch (error) {
                    console.error('Error processing offer:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);

                    // Provide more specific error messages
                    let errorMessage = 'Failed to process offer. ';
                    if (error.message.includes('decode')) {
                        errorMessage += 'The offer appears to be corrupted or invalid.';
                    } else if (error.message.includes('RTCPeerConnection')) {
                        errorMessage += 'WebRTC is not supported or permissions are blocked.';
                    } else if (error.message.includes('network') || error.message.includes('ICE')) {
                        errorMessage += 'Network connectivity issue. Check your internet connection.';
                    } else {
                        errorMessage += 'Please check the offer format and try again.';
                    }

                    alert(errorMessage);
                    this.hideLoaders();
                }
            }
            
            async processReceivedAnswer() {
                const answerText = document.getElementById('answerInput').value.trim();
                if (!answerText) {
                    alert('Please paste the answer you received.');
                    return;
                }
                
                try {
                    console.log('=== PROCESSING ANSWER (SENDER SIDE) ===');
                    console.log('Raw answer text length:', answerText.length);
                    
                    // Try to decode the compressed answer first
                    let answer;
                    try {
                        const decodedAnswer = decodeSDP(answerText);
                        if (!decodedAnswer) {
                            throw new Error('Failed to decode answer');
                        }
                        answer = decodedAnswer;
                        console.log('Successfully decoded compressed answer');
                    } catch (decodeError) {
                        console.log('Failed to decode compressed answer, trying raw JSON:', decodeError.message);
                        // Fallback: try to parse as raw JSON
                        try {
                            answer = JSON.parse(answerText);
                            console.log('Successfully parsed as raw JSON');
                        } catch (jsonError) {
                            console.error('Failed to parse as JSON:', jsonError.message);
                            throw new Error('Answer format is neither valid encoded format nor JSON');
                        }
                    }
                    
                    console.log('Parsed answer object:', answer);
                    console.log('Answer properties:', Object.keys(answer));
                    console.log('Answer type:', answer.type);
                    console.log('Answer SDP exists:', !!answer.sdp);
                    
                    // Validate answer format
                    if (!answer || typeof answer !== 'object') {
                        console.error('Answer is not a valid object:', answer);
                        throw new Error('Invalid answer format - not an object');
                    }
                    
                    if (!answer.sdp || typeof answer.sdp !== 'string') {
                        console.error('Answer missing or invalid SDP:', answer.sdp);
                        throw new Error('Invalid answer format - missing SDP');
                    }
                    
                    // Accept any type that looks like an answer
                    if (answer.type && answer.type !== 'answer') {
                        console.error('Answer has wrong type:', answer.type);
                        throw new Error('Invalid answer format - wrong type');
                    }
                    
                    // If no type is specified, assume it's an answer
                    if (!answer.type) {
                        console.log('No type specified, assuming answer type');
                        answer.type = 'answer';
                    }
                    
                    if (!this.peerConnection) {
                        alert('No peer connection found. Please generate an offer first.');
                        return;
                    }
                    
                    console.log('Setting remote description...');
                    console.log('Peer connection state:', this.peerConnection.connectionState);
                    console.log('ICE connection state:', this.peerConnection.iceConnectionState);
                    console.log('Signaling state:', this.peerConnection.signalingState);
                    
                    await this.peerConnection.setRemoteDescription(answer);
                    console.log('Remote description set successfully');
                    console.log('Data channel state:', this.dataChannel ? this.dataChannel.readyState : 'null');
                    
                    // Show success message
                    const statusMessage = document.createElement('div');
                    statusMessage.className = 'status connected';
                    statusMessage.textContent = '✅ Answer processed! Establishing connection...';
                    statusMessage.style.marginTop = '1rem';
                    
                    const answerInput = document.getElementById('answerInput');
                    if (answerInput.parentNode) {
                        answerInput.parentNode.insertBefore(statusMessage, answerInput.nextSibling);
                        
                        // Remove the message after 5 seconds
                        setTimeout(() => {
                            if (statusMessage.parentNode) {
                                statusMessage.remove();
                            }
                        }, 5000);
                    }
                    
                    // Connection will be established via data channel onopen event
                    console.log('Waiting for data channel to open...');
                    
                    // Set up a timeout to detect if data channel never opens
                    const connectionTimeout = setTimeout(() => {
                        if (this.dataChannel && this.dataChannel.readyState !== 'open') {
                            console.error('Data channel failed to open within 15 seconds');
                            console.log('Final data channel state:', this.dataChannel.readyState);
                            console.log('Final peer connection state:', this.peerConnection.connectionState);
                            console.log('Final ICE connection state:', this.peerConnection.iceConnectionState);
                            
                            // Show error message to user
                            const errorMessage = document.createElement('div');
                            errorMessage.className = 'status error';
                            errorMessage.textContent = '❌ Connection timeout. Please try again or check your network.';
                            errorMessage.style.marginTop = '1rem';
                            
                            const answerInput = document.getElementById('answerInput');
                            if (answerInput.parentNode) {
                                answerInput.parentNode.insertBefore(errorMessage, answerInput.nextSibling);
                            }
                        }
                    }, 15000); // 15 second timeout
                    
                    // Clear timeout if connection succeeds
                    if (this.dataChannel) {
                        const originalOnOpen = this.dataChannel.onopen;
                        this.dataChannel.onopen = () => {
                            clearTimeout(connectionTimeout);
                            if (originalOnOpen) originalOnOpen();
                        };
                    }
                    
                    // Also set up timeout clearing for data channels that might be received later
                    const originalSetupDataChannel = this.setupDataChannel.bind(this);
                    this.setupDataChannel = (channel) => {
                        clearTimeout(connectionTimeout);
                        originalSetupDataChannel(channel);
                    };
                    
                } catch (error) {
                    console.error('Error processing answer:', error);
                    console.error('Error details:', error.message);
                    console.error('Error stack:', error.stack);
                    
                    // Provide more specific error messages
                    let errorMessage = 'Failed to process answer. ';
                    if (error.message.includes('decode')) {
                        errorMessage += 'The answer appears to be corrupted or invalid.';
                    } else if (error.message.includes('JSON')) {
                        errorMessage += 'The answer is not in valid JSON format.';
                    } else if (error.message.includes('SDP')) {
                        errorMessage += 'The answer is missing required SDP information.';
                    } else if (error.message.includes('type')) {
                        errorMessage += 'The answer type is incorrect.';
                    } else {
                        errorMessage += 'Please check the answer format and try again.';
                    }
                    
                    alert(errorMessage);
                }
            }
            
            copyToClipboard(elementId) {
                const element = document.getElementById(elementId);
                element.select();
                document.execCommand('copy');
                
                // Show temporary feedback
                const originalText = element.nextElementSibling?.textContent;
                if (element.nextElementSibling && element.nextElementSibling.tagName === 'BUTTON') {
                    element.nextElementSibling.textContent = 'Copied!';
                    setTimeout(() => {
                        element.nextElementSibling.textContent = originalText || 'Copy';
                    }, 2000);
                }
            }
        }
        
        // Memory optimization: single global instance
        let appState;
        
        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                appState = new AppState();
            } catch (error) {
                console.error('Failed to initialize AppState:', error);
                alert('Failed to initialize app: ' + error.message);
            }
        });
        
        // Global functions for button clicks (memory optimization: avoid multiple event listeners)
        function createRoom() { 
            if (appState) {
                appState.createRoom(); 
            } else {
                console.error('appState is not initialized!');
                alert('App not initialized. Please refresh the page.');
            }
        }
        function joinRoom() { 
            if (appState) appState.joinRoom(); 
        }
        function playVsAI() { 
            if (appState) appState.playVsAI(); 
        }
        function playHotseat() { 
            if (appState) appState.playHotseat(); 
        }
        function backToLobby() { 
            if (appState) appState.backToLobby(); 
        }
        function closeJoinModal() { 
            if (appState) appState.closeJoinModal(); 
        }
        function connectToRoom() { 
            if (appState) appState.connectToRoom(); 
        }
        function startManualHandshake() { 
            if (appState) appState.startManualHandshake(); 
        }
        function closeHandshakeModal() { 
            if (appState) appState.closeHandshakeModal(); 
        }
        function processManualAnswer() { 
            if (appState) appState.processManualAnswer(); 
        }
        function openManualJoin() {
            if (appState) appState.openManualJoin();
        }
        function processReceivedOffer() {
            if (appState) appState.processReceivedOffer();
        }
        function startCreateMode() {
            if (appState) appState.startCreateMode();
        }
        function startJoinMode() {
            if (appState) appState.startJoinMode();
        }
        function processReceivedAnswer() {
            if (appState) appState.processReceivedAnswer();
        }
        function resetHandshakeModal() {
            if (appState) appState.resetHandshakeModal();
        }
        function copyToClipboard(elementId) {
            if (appState) appState.copyToClipboard(elementId);
        }
        
        function rematchGame() {
            if (appState) appState.rematchGame();
        }
        
        function selectGame(gameType) {
            if (appState) appState.selectGame(gameType);
        }
        
        function backToGameSelection() {
            if (appState) appState.backToGameSelection();
        }
        
        
        function makeNumGuess() {
            if (appState) appState.makeNumGuess();
        }
        
        // Debug test function
        function testCreateRoom() {
            
            // Check if appState exists
            if (appState) {
                
                // Check DOM elements
                const lobbyEl = document.getElementById('lobby');
                const roomInfoEl = document.getElementById('roomInfo');
                const roomIdEl = document.getElementById('roomId');
                
                
                
                // Test the createRoom method directly
                try {
                    appState.createRoom();
                } catch (error) {
                    console.error('Error calling createRoom:', error);
                }
            }
        }
        
        // Test SDP encoding/decoding functionality
        function testSDPEncoding() {

            // Test data - simulate a WebRTC offer/answer
            const testSDP = {
                type: 'offer',
                sdp: 'v=0\r\no=- 123456789 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\na=group:BUNDLE data\r\na=msid-semantic: WMS\r\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\r\nc=IN IP4 127.0.0.1\r\na=candidate:1 1 UDP 2122260223 192.168.1.1 12345 typ host generation 0\r\na=candidate:2 1 UDP 2122194687 10.0.0.1 12346 typ host generation 0\r\na=ice-ufrag:abcd\r\na=ice-pwd:efgh\r\na=fingerprint:sha-256 12:34:56:78:9A:BC:DE:F0:12:34:56:78:9A:BC:DE:F0:12:34:56:78:9A:BC:DE:F0\r\na=setup:actpass\r\na=mid:data\r\na=sctp-port:5000\r\na=max-message-size:262144'
            };

            const originalJSON = JSON.stringify(testSDP);
            
            // Test compression separately
            const compressed = simpleCompress(originalJSON);
           
            // Test encoding
            const encoded = encodeSDP(testSDP);
           
            // Test decoding
            const decoded = decodeSDP(encoded);

            // Test round-trip integrity
            const isEqual = JSON.stringify(testSDP) === JSON.stringify(decoded);

            if (isEqual) {
                const finalCompressionRatio = (originalJSON.length / encoded.length).toFixed(2);
            }

            console.log('=== PURE JS TEST COMPLETE ===');
        }

        // Memory snapshot export function
        function exportMemorySnapshot() {
            if (performance.memory) {
                const memory = performance.memory;
                const snapshot = {
                    usedJSHeapSize: `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                    totalJSHeapSize: `${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                    jsHeapSizeLimit: `${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`,
                    timestamp: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(snapshot, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'memory-snapshot.json';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        
    </script>
</body>
</html>
