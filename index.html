<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decentralized Game Room</title>
    <style>
        /* Memory-optimized CSS - minimal selectors, no large assets */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a; color: #fff; 
            overflow-x: hidden;
        }
        .container { 
            max-width: 800px; margin: 0 auto; padding: 20px;
            min-height: 100vh;
        }
        .header { 
            text-align: center; margin-bottom: 30px;
            padding: 20px 0; border-bottom: 2px solid #333;
        }
        .header h1 { 
            font-size: 2.5rem; margin-bottom: 10px;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .lobby { 
            text-align: center; margin-bottom: 30px;
        }
        .btn { 
            background: #00ff88; color: #000; border: none;
            padding: 15px 30px; margin: 10px; border-radius: 8px;
            font-size: 1.1rem; font-weight: bold; cursor: pointer;
            transition: all 0.2s; min-width: 200px;
        }
        .btn:hover { background: #00cc66; transform: translateY(-2px); }
        .btn:disabled { background: #666; cursor: not-allowed; transform: none; }
        .btn.offline { background: #ffaa00; }
        .btn.offline:hover { background: #ff8800; }
        
        .loader {
            border: 3px solid #333;
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .game-over-actions {
            text-align: center;
            margin-top: 20px;
        }
        
        .room-info { 
            background: #333; padding: 20px; border-radius: 8px;
            margin: 20px 0; text-align: center;
        }
        .room-id { 
            font-family: monospace; font-size: 1.5rem; color: #00ff88;
            background: #000; padding: 10px; border-radius: 4px;
            display: inline-block; margin: 10px 0;
        }
        .status { 
            padding: 10px; margin: 10px 0; border-radius: 4px;
            font-weight: bold;
        }
        .status.waiting { background: #ffaa00; color: #000; }
        .status.connected { background: #00ff88; color: #000; }
        .status.error { background: #ff4444; color: #fff; }
        .status.offline { background: #666; color: #fff; }
        .status.info { background: #00ccff; color: #000; }
        
        .game-board { 
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 10px; max-width: 300px; margin: 20px auto;
        }
        .cell { 
            width: 80px; height: 80px; background: #333;
            border: 2px solid #00ff88; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; font-weight: bold; cursor: pointer;
            transition: all 0.2s;
        }
        .cell:hover { background: #444; }
        .cell.x { color: #ff4444; }
        .cell.o { color: #00ccff; }
        
        .debug-panel { 
            position: fixed; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.9); padding: 15px;
            border-radius: 8px; border: 1px solid #00ff88;
            font-family: monospace; font-size: 0.9rem;
            min-width: 250px;
        }
        .debug-panel h3 { 
            color: #00ff88; margin-bottom: 10px;
            font-size: 1rem;
        }
        .debug-item { 
            margin: 5px 0; color: #ccc;
        }
        .debug-item strong { color: #fff; }
        
        .hidden { display: none; }
        .back-btn { 
            background: #666; margin-top: 20px;
        }
        .back-btn:hover { background: #555; }
        
        .manual-handshake { 
            background: #222; padding: 15px; border-radius: 8px;
            margin: 15px 0; text-align: left;
            font-family: monospace; font-size: 0.9rem;
        }
        .manual-handshake h4 { color: #00ff88; margin-bottom: 10px; }
        .manual-handshake p { margin: 5px 0; color: #ccc; }
        
        .error-message {
            background: #ff4444; color: #fff; padding: 10px; margin: 10px 0;
            border-radius: 4px; font-weight: bold;
        }
        
        /* Memory optimization: minimal animations, no heavy effects */
        @media (max-width: 600px) {
            .container { padding: 10px; }
            .btn { min-width: 150px; padding: 12px 20px; }
            .cell { width: 60px; height: 60px; font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ® Decentralized Game Room</h1>
            <p>P2P Gaming with Offline-First Design</p>
        </div>
        
        <!-- Lobby View -->
        <div id="lobby" class="lobby">
            <h2>Choose Your Game Mode</h2>
            <button class="btn" onclick="createRoom()">Create Room</button>
            <button class="btn" onclick="joinRoom()">Join Room</button>
            <button class="btn offline" onclick="playVsAI()">Play vs AI (Offline)</button>
            <button class="btn offline" onclick="playHotseat()">Hotseat (Offline)</button>
            

        </div>
        
        <!-- Room Info View (Moved outside lobby) -->
        <div id="roomInfo" class="room-info hidden">
            <h3>Room Created!</h3>
            <div class="room-id" id="roomId"></div>
            <p>Share this room ID with your friend</p>
            <div class="status waiting" id="roomStatus">Waiting for peer...</div>
            
            <!-- Manual handshake section for P2P without server -->
            <div class="manual-handshake">
                <h4>ðŸ”— Manual P2P Connection (No Server Required)</h4>
                <p><strong>Step 1:</strong> Share this room ID with your friend</p>
                <p><strong>Step 2:</strong> Both players click "Join Room" and enter the same room ID</p>
                <p><strong>Step 3:</strong> Use the manual handshake below if signaling server is unavailable</p>
            </div>
            
            <button class="btn" onclick="startManualHandshake()">Start Manual Handshake</button>
            <button class="btn back-btn" onclick="backToLobby()">Back to Lobby</button>
        </div>
        
        <!-- Game View -->
        <div id="game" class="hidden">
            <h2 id="gameTitle">Tic-Tac-Toe</h2>
            <div class="game-board" id="gameBoard"></div>
            <div class="status" id="gameStatus">Your turn!</div>
            
            <!-- Game Over Actions -->
            <div id="gameOverActions" class="game-over-actions hidden">
                <button class="btn" onclick="rematchGame()">Rematch</button>
                <button class="btn back-btn" onclick="backToLobby()">Home</button>
            </div>
            
            <button class="btn back-btn" onclick="backToLobby()">Back to Lobby</button>
        </div>
        
        <!-- Join Room Modal -->
        <div id="joinModal" class="hidden">
            <h3>Join Room</h3>
            <div id="joinError" class="error-message hidden"></div>
            <input type="text" id="roomInput" placeholder="Enter room ID" style="padding: 10px; margin: 10px; width: 200px; border-radius: 4px; border: 1px solid #333;">
            <button class="btn" onclick="connectToRoom()">Join</button>
            <button class="btn" onclick="openManualJoin()">Manual Handshake</button>
            <button class="btn" onclick="closeJoinModal()">Cancel</button>
        </div>
        
        <!-- Manual Handshake Modal -->
        <div id="handshakeModal" class="hidden">
            <h3>Manual P2P Handshake</h3>
            <div class="manual-handshake">
                <!-- Mode Selection -->
                <div id="modeSelection">
                    <h4>Choose your role:</h4>
                    <button class="btn" onclick="startCreateMode()">Generate Link for Friend<span id="createLoader" class="loader hidden"></span></button>
                    <button class="btn" onclick="startJoinMode()">I Have a Link</button>
                </div>
                
                <!-- CREATE MODE: Generate offer for sharing -->
                <div id="createMode" class="hidden">
                    <h4>Step 1: Share this offer with your friend</h4>
                    <textarea id="offerText" readonly style="width: 100%; height: 100px; background: #000; color: #00ff88; border: 1px solid #333; padding: 10px; font-family: monospace; margin: 10px 0;"></textarea>
                    <button class="btn" onclick="copyToClipboard('offerText')">Copy Offer</button>
                    
                    <h4>Step 2: Paste the answer you receive back</h4>
                    <textarea id="answerInput" placeholder="Paste the answer your friend sends back..." style="width: 100%; height: 100px; background: #000; color: #00ff88; border: 1px solid #333; padding: 10px; font-family: monospace; margin: 10px 0;"></textarea>
                    <button class="btn" onclick="processReceivedAnswer()">Connect with Answer</button>
                </div>
                
                <!-- JOIN MODE: Process offer and generate answer -->
                <div id="joinMode" class="hidden">
                    <h4>Step 1: Paste the offer you received</h4>
                    <textarea id="receivedOfferInput" placeholder='Paste the offer here (e.g., {"type":"offer","sdp":"v=0..."})' style="width: 100%; height: 100px; background: #000; color: #00ff88; border: 1px solid #333; padding: 10px; font-family: monospace; margin: 10px 0;"></textarea>
                    <button class="btn" onclick="processReceivedOffer()">Generate Answer<span id="answerLoader" class="loader hidden"></span></button>
                    
                    <!-- Answer generated - show to user -->
                    <div id="generatedAnswerSection" class="hidden">
                        <h4>Step 2: Send this answer back to your friend</h4>
                        <textarea id="answerText" readonly style="width: 100%; height: 100px; background: #000; color: #00ff88; border: 1px solid #333; padding: 10px; font-family: monospace; margin: 10px 0;"></textarea>
                        <button class="btn" onclick="copyToClipboard('answerText')">Copy Answer</button>
                        <div class="status info">Answer generated! Copy and send it back. Connection will establish automatically.</div>
                    </div>
                </div>
                
                <button class="btn back-btn" onclick="resetHandshakeModal()">Back to Mode Selection</button>
                <button class="btn back-btn" onclick="closeHandshakeModal()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Debug Panel -->
    <div class="debug-panel">
        <h3>ðŸ”§ Debug Info</h3>
        <div class="debug-item">Memory: <strong id="memoryUsage">--</strong></div>
        <div class="debug-item">Online: <strong id="onlineStatus">--</strong></div>
        <div class="debug-item">Peer: <strong id="peerStatus">--</strong></div>
        <div class="debug-item">Game State: <strong id="gameState">--</strong></div>
        <button onclick="exportMemorySnapshot()" style="background: #333; color: #fff; border: none; padding: 5px 10px; border-radius: 4px; margin-top: 10px; cursor: pointer; font-size: 0.8rem;">Export Memory Snapshot</button>
    </div>

    <script>
        // Memory-optimized game engine - single source for all modes
        class GameEngine {
            constructor() {
                this.reset();
                this.MAX_HISTORY = 50; // Memory optimization: limit move history
            }
            
            reset() {
                this.board = Array(9).fill('');
                this.currentPlayer = 'x';
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = []; // Memory optimization: limited history
            }
            
            makeMove(index) {
                if (this.board[index] !== '' || this.gameOver) return false;
                
                this.board[index] = this.currentPlayer;
                this.moveHistory.push({player: this.currentPlayer, index: index});
                
                // Memory optimization: trim history if too long
                if (this.moveHistory.length > this.MAX_HISTORY) {
                    this.moveHistory.shift();
                }
                
                if (this.checkWin(index)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    return true;
                }
                
                if (this.checkDraw()) {
                    this.gameOver = true;
                    this.winner = 'draw';
                    return true;
                }
                
                this.currentPlayer = this.currentPlayer === 'x' ? 'o' : 'x';
                return true;
            }
            
            checkWin(index) {
                const lines = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6] // diagonals
                ];
                
                return lines.some(line => 
                    line.includes(index) && 
                    this.board[line[0]] && 
                    this.board[line[0]] === this.board[line[1]] && 
                    this.board[line[1]] === this.board[line[2]]
                );
            }
            
            checkDraw() {
                return this.board.every(cell => cell !== '');
            }
            
            // Deterministic AI - same result every time for given board state
            getAIMove() {
                const emptyCells = this.board.map((cell, index) => cell === '' ? index : -1).filter(i => i !== -1);
                if (emptyCells.length === 0) return -1;
                
                // Simple deterministic strategy: prefer center, then corners, then edges
                const priority = [4, 0, 2, 6, 8, 1, 3, 5, 7];
                for (let pos of priority) {
                    if (emptyCells.includes(pos)) return pos;
                }
                return emptyCells[0];
            }
            
            // Compact serialization for network messages
            serializeMove(index) {
                return `mv:${index}`; // Memory optimization: tiny message format
            }
            
            deserializeMove(message) {
                if (message.startsWith('mv:')) {
                    return parseInt(message.substring(3));
                }
                return -1;
            }
        }
        
        // Memory-optimized app state manager
        class AppState {
            constructor() {
                this.gameEngine = new GameEngine();
                this.currentMode = 'lobby';
                this.roomId = null;
                this.peerConnection = null;
                this.dataChannel = null;
                this.signalingServer = null;
                this.isOnline = navigator.onLine;
                this.memoryUpdateInterval = null;
                this.isInitiator = false; // Track if this peer initiated the connection
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.startMemoryMonitoring();
                this.updateOnlineStatus();
                this.registerServiceWorker();
            }
            
            setupEventListeners() {
                window.addEventListener('online', () => this.updateOnlineStatus());
                window.addEventListener('offline', () => this.updateOnlineStatus());
                
                // Memory optimization: single event listener for game board
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('cell')) {
                        const index = parseInt(e.target.dataset.index);
                        this.handleCellClick(index);
                    }
                });
            }
            
            startMemoryMonitoring() {
                // Memory optimization: update every 2 seconds instead of every second
                this.memoryUpdateInterval = setInterval(() => {
                    this.updateDebugInfo();
                }, 2000);
            }
            
            updateOnlineStatus() {
                this.isOnline = navigator.onLine;
                this.updateDebugInfo();
                
                if (!this.isOnline && this.currentMode === 'lobby') {
                    this.showOfflineMessage();
                }
            }
            
            showOfflineMessage() {
                const status = document.getElementById('roomStatus');
                if (status) {
                    status.textContent = 'Offline mode - AI and Hotseat available';
                    status.className = 'status offline';
                }
            }
            
            updateDebugInfo() {
                // Memory optimization: only update DOM when values change
                const memoryEl = document.getElementById('memoryUsage');
                const onlineEl = document.getElementById('onlineStatus');
                const peerEl = document.getElementById('peerStatus');
                const gameStateEl = document.getElementById('gameState');
                
                if (memoryEl && performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    memoryEl.textContent = `${memoryMB} MB`;
                }
                
                if (onlineEl) onlineEl.textContent = this.isOnline ? 'true' : 'false';
                if (peerEl) peerEl.textContent = this.dataChannel ? 'connected' : 'none';
                if (gameStateEl) gameStateEl.textContent = this.currentMode;
            }
            
            async registerServiceWorker() {
                // Skip Service Worker registration for file:// protocol
                if (window.location.protocol === 'file:') {
                    console.log('Skipping Service Worker registration (file:// protocol not supported)');
                    return;
                }
                
                if ('serviceWorker' in navigator) {
                    try {
                        await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker registered');
                    } catch (error) {
                        console.log('Service Worker registration failed:', error);
                    }
                }
            }
            
            // Game mode handlers
            createRoom() {
                console.log('Creating room...');
                this.roomId = this.generateRoomId();
                this.currentMode = 'waiting';
                this.isInitiator = true;
                
                console.log('Room ID generated:', this.roomId);
                this.showRoomInfo();
                
                // Try to connect to signaling server, but don't fail if unavailable
                if (this.isOnline) {
                    this.connectToSignalingServer();
                } else {
                    this.updateRoomStatus('Room created! Share room ID with peer.', 'info');
                }
            }
            
            joinRoom() {
                this.showJoinModal();
            }
            
            playVsAI() {
                this.currentMode = 'ai';
                this.gameEngine.reset();
                this.showGame();
            }
            
            playHotseat() {
                this.currentMode = 'hotseat';
                this.gameEngine.reset();
                this.showGame();
            }
            
            generateRoomId() {
                // Memory optimization: simple ID generation
                return 'r' + Math.random().toString(36).substring(2, 8);
            }
            
            showRoomInfo() {
                console.log('Showing room info for room:', this.roomId);
                
                // Debug: Check if elements exist
                const lobbyEl = document.getElementById('lobby');
                const roomInfoEl = document.getElementById('roomInfo');
                const roomIdEl = document.getElementById('roomId');
                
                console.log('DOM elements found:', {
                    lobby: !!lobbyEl,
                    roomInfo: !!roomInfoEl,
                    roomId: !!roomIdEl
                });
                
                if (!lobbyEl || !roomInfoEl || !roomIdEl) {
                    console.error('Required DOM elements not found!');
                    alert('Required elements not found. Please refresh the page.');
                    return;
                }
                
                // Hide lobby and show room info
                lobbyEl.classList.add('hidden');
                roomInfoEl.classList.remove('hidden');
                
                // Update room ID
                roomIdEl.textContent = this.roomId;
                console.log('Room ID element updated with:', this.roomId);
                console.log('Room info should now be visible');
            }
            
            showGame() {
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('game').classList.remove('hidden');
                this.renderGameBoard();
            }
            
            backToLobby() {
                this.currentMode = 'lobby';
                this.gameEngine.reset();
                this.cleanupConnection();
                this.isInitiator = false;
                document.getElementById('game').classList.add('hidden');
                document.getElementById('roomInfo').classList.add('hidden');
                document.getElementById('lobby').classList.remove('hidden');
            }
            
            showJoinModal() {
                document.getElementById('joinModal').classList.remove('hidden');
                document.getElementById('joinError').classList.add('hidden');
                document.getElementById('roomInput').value = '';
            }
            
            closeJoinModal() {
                document.getElementById('joinModal').classList.add('hidden');
            }
            
            async connectToRoom() {
                const roomId = document.getElementById('roomInput').value.trim();
                const errorEl = document.getElementById('joinError');
                
                // Validation
                if (!roomId) {
                    errorEl.textContent = 'Please enter a room ID';
                    errorEl.classList.remove('hidden');
                    return;
                }
                
                if (roomId.length < 3) {
                    errorEl.textContent = 'Room ID must be at least 3 characters';
                    errorEl.classList.remove('hidden');
                    return;
                }
                
                console.log('Joining room:', roomId);
                this.roomId = roomId;
                this.currentMode = 'network';
                this.isInitiator = false;
                this.closeJoinModal();
                this.showRoomInfo();
                
                if (this.isOnline) {
                    this.connectToSignalingServer();
                } else {
                    this.updateRoomStatus('Offline mode - use manual handshake', 'offline');
                }
            }
            
            updateRoomStatus(message, type = 'waiting') {
                const statusEl = document.getElementById('roomStatus');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.className = `status ${type}`;
                }
            }
            
            // WebRTC and signaling
            async connectToSignalingServer() {
                try {
                    console.log('Connecting to signaling server...');
                    this.signalingServer = new WebSocket('ws://localhost:8080');
                    
                    this.signalingServer.onopen = () => {
                        console.log('Connected to signaling server');
                        if (this.isInitiator) {
                            // Create room on server
                            this.signalingServer.send(JSON.stringify({
                                t: 'create',
                                room: this.roomId
                            }));
                        } else {
                            // Join room on server
                            this.signalingServer.send(JSON.stringify({
                                t: 'join',
                                room: this.roomId
                            }));
                        }
                    };
                    
                    this.signalingServer.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        console.log('Received signaling message:', message);
                        this.handleSignalingMessage(message);
                    };
                    
                    this.signalingServer.onerror = () => {
                        console.log('Signaling server error');
                        this.handleSignalingError();
                    };
                    
                    this.signalingServer.onclose = () => {
                        console.log('Signaling server disconnected');
                        this.handleSignalingError();
                    };
                    
                    // Memory optimization: timeout for signaling
                    setTimeout(() => {
                        if (!this.dataChannel) {
                            this.handleSignalingError();
                        }
                    }, 10000);
                    
                } catch (error) {
                    console.log('Signaling connection failed:', error);
                    this.handleSignalingError();
                }
            }
            
            handleSignalingMessage(message) {
                console.log('Handling signaling message:', message);
                switch (message.t) {
                    case 'created':
                        this.updateRoomStatus('Room created on server. Waiting for peer...', 'waiting');
                        break;
                    case 'peer_joined':
                        this.updateRoomStatus('Peer joined! Establishing connection...', 'info');
                        if (this.isInitiator) {
                            this.createPeerConnection();
                        }
                        break;
                    case 'offer':
                        this.handleOffer(message.offer);
                        break;
                    case 'answer':
                        this.handleAnswer(message.answer);
                        break;
                    case 'ice':
                        this.handleIceCandidate(message.cand);
                        break;
                    default:
                        console.log('Unknown message type:', message.t);
                }
            }
            
            async createPeerConnection() {
                try {
                    console.log('Creating peer connection...');
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.signalingServer) {
                            this.signalingServer.send(JSON.stringify({
                                t: 'ice',
                                room: this.roomId,
                                cand: event.candidate
                            }));
                        }
                    };
                    
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    if (this.signalingServer) {
                        this.signalingServer.send(JSON.stringify({
                            t: 'offer',
                            room: this.roomId,
                            offer: offer
                        }));
                    }
                    
                } catch (error) {
                    console.log('Error creating peer connection:', error);
                    this.handleSignalingError();
                }
            }
            
            async handleOffer(offer) {
                try {
                    if (!this.peerConnection) {
                        this.peerConnection = new RTCPeerConnection({
                            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                        });
                        
                        this.peerConnection.ondatachannel = (event) => {
                            this.setupDataChannel(event.channel);
                        };
                        
                        this.peerConnection.onicecandidate = (event) => {
                            if (event.candidate && this.signalingServer) {
                                this.signalingServer.send(JSON.stringify({
                                    t: 'ice',
                                    room: this.roomId,
                                    cand: event.candidate
                                }));
                            }
                        };
                    }
                    
                    await this.peerConnection.setRemoteDescription(offer);
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    
                    if (this.signalingServer) {
                        this.signalingServer.send(JSON.stringify({
                            t: 'answer',
                            room: this.roomId,
                            answer: answer
                        }));
                    }
                    
                } catch (error) {
                    console.log('Error handling offer:', error);
                    this.handleSignalingError();
                }
            }
            
            async handleAnswer(answer) {
                try {
                    console.log('=== HANDLING ANSWER ===');
                    console.log('Answer object:', answer);
                    console.log('Answer properties:', Object.keys(answer));
                    console.log('Answer type:', answer.type);
                    console.log('Answer SDP exists:', !!answer.sdp);
                    
                    // Validate answer format
                    if (!answer || typeof answer !== 'object') {
                        console.error('Answer is not a valid object:', answer);
                        throw new Error('Invalid answer format - not an object');
                    }
                    
                    if (!answer.sdp || typeof answer.sdp !== 'string') {
                        console.error('Answer missing or invalid SDP:', answer.sdp);
                        throw new Error('Invalid answer format - missing SDP');
                    }
                    
                    // Accept any type that looks like an answer
                    if (answer.type && answer.type !== 'answer') {
                        console.error('Answer has wrong type:', answer.type);
                        throw new Error('Invalid answer format - wrong type');
                    }
                    
                    // If no type is specified, assume it's an answer
                    if (!answer.type) {
                        console.log('No type specified, assuming answer type');
                        answer.type = 'answer';
                    }
                    
                    await this.peerConnection.setRemoteDescription(answer);
                    console.log('Remote description set successfully');
                } catch (error) {
                    console.error('Error handling answer:', error);
                    throw error; // Re-throw to be caught by the calling function
                }
            }
            
            handleIceCandidate(candidate) {
                if (this.peerConnection) {
                    this.peerConnection.addIceCandidate(candidate);
                }
            }
            
            setupDataChannel(channel) {
                this.dataChannel = channel;
                console.log('Setting up data channel, current state:', channel.readyState);
                
                this.dataChannel.onopen = () => {
                    console.log('=== DATA CHANNEL OPENED ===');
                    console.log('Channel state:', this.dataChannel.readyState);
                    this.updatePeerStatus('connected');
                    
                    // Set network mode and show game for both sender and receiver
                    this.currentMode = 'network';
                    this.gameEngine.reset();
                    
                    // Assign player symbols based on who initiated the connection
                    // If we have a data channel that we created, we're the host (X)
                    // If we received a data channel, we're the joiner (O)
                    if (this.peerConnection && this.peerConnection.localDescription && this.peerConnection.localDescription.type === 'offer') {
                        // We created the offer, so we're the host (X)
                        this.myPlayerSymbol = 'x';
                        console.log('I am the host (created offer), playing as X');
                    } else {
                        // We received the offer and created the answer, so we're the joiner (O)
                        this.myPlayerSymbol = 'o';
                        console.log('I am the joiner (created answer), playing as O');
                    }
                    
                    // Close any open modals and show game
                    this.closeHandshakeModal();
                    this.closeJoinModal();
                    this.showGame();
                    this.renderGameBoard();
                    
                    console.log('=== GAME VIEW SHOULD BE VISIBLE NOW ===');
                };
                
                this.dataChannel.onerror = (error) => {
                    console.error('Data channel error:', error);
                };
                
                this.dataChannel.onclose = () => {
                    console.log('Data channel closed');
                };
                
                this.dataChannel.onmessage = (event) => {
                    console.log('Received message:', event.data);
                    
                    // Handle rematch signal
                    if (event.data === 'rematch') {
                        this.gameEngine.reset();
                        const gameOverActionsEl = document.getElementById('gameOverActions');
                        if (gameOverActionsEl) {
                            gameOverActionsEl.classList.add('hidden');
                        }
                        this.renderGameBoard();
                        this.updateGameStatus();
                        return;
                    }
                    
                    // Handle game moves
                    const move = this.gameEngine.deserializeMove(event.data);
                    if (move !== -1) {
                        this.gameEngine.makeMove(move);
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                };
                
                this.dataChannel.onclose = () => {
                    console.log('Data channel closed');
                    this.updatePeerStatus('disconnected');
                };
            }
            
            handleSignalingError() {
                console.log('Signaling failed, suggesting manual handshake');
                this.updateRoomStatus('Signaling server unavailable. Use manual handshake below.', 'error');
            }
            
            updatePeerStatus(status) {
                const statusEl = document.getElementById('peerStatus');
                if (statusEl) {
                    statusEl.textContent = status;
                }
            }
            
            // Manual handshake methods
            startManualHandshake() {
                this.resetHandshakeModal();
                this.clearHandshakeInputs();
                document.getElementById('handshakeModal').classList.remove('hidden');
            }
            
            closeHandshakeModal() {
                document.getElementById('handshakeModal').classList.add('hidden');
            }
            
            async processManualAnswer() {
                const answerText = document.getElementById('answerInput').value.trim();
                if (!answerText) return;
                
                try {
                    const answer = JSON.parse(answerText);
                    await this.handleAnswer(answer);
                    this.closeHandshakeModal();
                } catch (error) {
                    console.log('Error processing manual answer:', error);
                    alert('Invalid answer format. Please check the peer\'s answer.');
                }
            }
            
            // Game rendering and interaction
            renderGameBoard() {
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                
                // Memory optimization: reuse DOM nodes where possible
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    
                    if (this.gameEngine.board[i] === 'x') {
                        cell.textContent = 'X';
                        cell.classList.add('x');
                    } else if (this.gameEngine.board[i] === 'o') {
                        cell.textContent = 'O';
                        cell.classList.add('o');
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            handleCellClick(index) {
                if (this.gameEngine.gameOver) return;
                
                // AI mode: player vs AI
                if (this.currentMode === 'ai' && this.gameEngine.currentPlayer === 'x') {
                    if (this.gameEngine.makeMove(index)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                        
                        // AI move after a short delay
                        setTimeout(() => {
                            if (!this.gameEngine.gameOver) {
                                const aiMove = this.gameEngine.getAIMove();
                                if (aiMove !== -1) {
                                    this.gameEngine.makeMove(aiMove);
                                    this.renderGameBoard();
                                    this.updateGameStatus();
                                }
                            }
                        }, 500);
                    }
                }
                // Hotseat mode: alternating players
                else if (this.currentMode === 'hotseat') {
                    if (this.gameEngine.makeMove(index)) {
                        this.renderGameBoard();
                        this.updateGameStatus();
                    }
                }
                // Network mode: only current player can move
                else if (this.currentMode === 'network' && this.dataChannel && this.dataChannel.readyState === 'open') {
                    // Check if it's this player's turn
                    if (this.gameEngine.currentPlayer === this.myPlayerSymbol) {
                        const moveMessage = this.gameEngine.serializeMove(index);
                        this.dataChannel.send(moveMessage);
                        
                        if (this.gameEngine.makeMove(index)) {
                            this.renderGameBoard();
                            this.updateGameStatus();
                        }
                    }
                }
            }
            
            updateGameStatus() {
                const statusEl = document.getElementById('gameStatus');
                const gameOverActionsEl = document.getElementById('gameOverActions');
                if (!statusEl) return;
                
                if (this.gameEngine.gameOver) {
                    if (this.gameEngine.winner === 'draw') {
                        statusEl.textContent = "It's a draw!";
                        statusEl.className = 'status';
                    } else {
                        statusEl.textContent = `Player ${this.gameEngine.winner.toUpperCase()} wins!`;
                        statusEl.className = 'status connected';
                    }
                    
                    // Show game over actions
                    if (gameOverActionsEl) {
                        gameOverActionsEl.classList.remove('hidden');
                    }
                } else {
                    statusEl.textContent = `Player ${this.gameEngine.currentPlayer.toUpperCase()}'s turn`;
                    statusEl.className = 'status';
                    
                    // Hide game over actions
                    if (gameOverActionsEl) {
                        gameOverActionsEl.classList.add('hidden');
                    }
                }
            }
            
            rematchGame() {
                // Reset game engine
                this.gameEngine.reset();
                
                // Hide game over actions
                const gameOverActionsEl = document.getElementById('gameOverActions');
                if (gameOverActionsEl) {
                    gameOverActionsEl.classList.add('hidden');
                }
                
                // Re-render board and update status
                this.renderGameBoard();
                this.updateGameStatus();
                
                // If in network mode, send rematch signal to peer
                if (this.currentMode === 'network' && this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send('rematch');
                }
            }
            
            cleanupConnection() {
                if (this.dataChannel) {
                    this.dataChannel.close();
                    this.dataChannel = null;
                }
                if (this.peerConnection) {
                    this.peerConnection.close();
                    this.peerConnection = null;
                }
                if (this.signalingServer) {
                    this.signalingServer.close();
                    this.signalingServer = null;
                }
            }
            
            // New methods for manual handshake functionality
            openManualJoin() {
                this.closeJoinModal();
                document.getElementById('handshakeModal').classList.remove('hidden');
                this.clearHandshakeInputs();
                // Skip mode selection and go directly to join mode
                this.startJoinMode();
            }
            
            resetHandshakeModal() {
                document.getElementById('modeSelection').classList.remove('hidden');
                document.getElementById('createMode').classList.add('hidden');
                document.getElementById('joinMode').classList.add('hidden');
                document.getElementById('generatedAnswerSection').classList.add('hidden');
                this.hideLoaders();
            }
            
            clearHandshakeInputs() {
                document.getElementById('offerText').value = '';
                document.getElementById('answerInput').value = '';
                document.getElementById('receivedOfferInput').value = '';
                document.getElementById('answerText').value = '';
            }
            
            hideLoaders() {
                document.getElementById('createLoader').classList.add('hidden');
                document.getElementById('answerLoader').classList.add('hidden');
            }
            
            showLoader(loaderId) {
                document.getElementById(loaderId).classList.remove('hidden');
            }
            
            startCreateMode() {
                document.getElementById('modeSelection').classList.add('hidden');
                document.getElementById('createMode').classList.remove('hidden');
                document.getElementById('joinMode').classList.add('hidden');
                
                // Show loader and generate offer
                this.showLoader('createLoader');
                this.generateOffer();
            }
            
            startJoinMode() {
                document.getElementById('modeSelection').classList.add('hidden');
                document.getElementById('createMode').classList.add('hidden');
                document.getElementById('joinMode').classList.remove('hidden');
                document.getElementById('generatedAnswerSection').classList.add('hidden');
            }
            
            async generateOffer() {
                try {
                    console.log('=== GENERATING OFFER (SENDER SIDE) ===');
                    
                    // Create completely new peer connection
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Set up ICE candidate gathering
                    pc.onicecandidate = (event) => {
                        console.log('ICE candidate generated:', event.candidate);
                        // For manual handshake, we'll include candidates in the offer
                    };
                    
                    pc.onconnectionstatechange = () => {
                        console.log('Connection state changed:', pc.connectionState);
                    };
                    
                    // Create data channel
                    const dc = pc.createDataChannel('gameData');
                    console.log('Data channel created:', dc.label);
                    
                    // Create offer and wait for ICE gathering
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // Wait for ICE gathering to complete (with timeout)
                    await Promise.race([
                        new Promise((resolve) => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                pc.addEventListener('icegatheringstatechange', () => {
                                    if (pc.iceGatheringState === 'complete') {
                                        resolve();
                                    }
                                });
                            }
                        }),
                        new Promise((resolve) => setTimeout(resolve, 3000)) // 3 second timeout
                    ]);
                    console.log('Offer ICE gathering state:', pc.iceGatheringState);
                    
                    // Only assign to instance variables after successful creation
                    this.peerConnection = pc;
                    this.dataChannel = dc;
                    this.setupDataChannel(dc);
                    
                    // Display complete offer with ICE candidates
                    const completeOffer = pc.localDescription;
                    document.getElementById('offerText').value = JSON.stringify(completeOffer);
                    console.log('Complete offer generated with ICE candidates');
                    
                    // Hide loader
                    this.hideLoaders();
                    
                } catch (error) {
                    console.error('Error generating offer:', error);
                    alert('Failed to generate offer. Please try again.');
                    this.hideLoaders();
                }
            }
            
            async processReceivedOffer() {
                const offerText = document.getElementById('receivedOfferInput').value.trim();
                if (!offerText) {
                    alert('Please paste the offer you received.');
                    return;
                }
                
                // Show loader
                this.showLoader('answerLoader');
                
                try {
                    console.log('=== PROCESSING OFFER (RECEIVER SIDE) ===');
                    const offer = JSON.parse(offerText);
                    if (offer.type !== 'offer' || !offer.sdp) {
                        throw new Error('Invalid offer format');
                    }
                    
                    // Clean up any existing connection
                    if (this.peerConnection) {
                        this.peerConnection.close();
                        this.peerConnection = null;
                    }
                    if (this.dataChannel) {
                        this.dataChannel.close();
                        this.dataChannel = null;
                    }
                    
                    // Create fresh peer connection for receiver
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    console.log('Peer connection created on receiver side');
                    
                    // Set up connection state monitoring
                    this.peerConnection.onconnectionstatechange = () => {
                        console.log('Receiver connection state:', this.peerConnection.connectionState);
                    };
                    
                    await this.peerConnection.setRemoteDescription(offer);
                    console.log('Remote description set');
                    
                    // Create answer
                    const answer = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(answer);
                    console.log('Answer created and local description set');
                    
                    // Wait for ICE gathering to complete (with timeout)
                    await Promise.race([
                        new Promise((resolve) => {
                            if (this.peerConnection.iceGatheringState === 'complete') {
                                resolve();
                            } else {
                                this.peerConnection.addEventListener('icegatheringstatechange', () => {
                                    if (this.peerConnection.iceGatheringState === 'complete') {
                                        resolve();
                                    }
                                });
                            }
                        }),
                        new Promise((resolve) => setTimeout(resolve, 3000)) // 3 second timeout
                    ]);
                    console.log('ICE gathering state:', this.peerConnection.iceGatheringState);
                    
                    // Display the complete answer with ICE candidates
                    const completeAnswer = this.peerConnection.localDescription;
                    console.log('Generated complete answer object:', completeAnswer);
                    console.log('Answer type:', completeAnswer.type);
                    console.log('Answer SDP exists:', !!completeAnswer.sdp);
                    document.getElementById('answerText').value = JSON.stringify(completeAnswer);
                    document.getElementById('generatedAnswerSection').classList.remove('hidden');
                    
                    // Set up data channel handling for receiver
                    this.peerConnection.ondatachannel = (event) => {
                        console.log('=== DATA CHANNEL RECEIVED ON RECEIVER ===');
                        console.log('Channel label:', event.channel.label);
                        console.log('Channel state:', event.channel.readyState);
                        this.setupDataChannel(event.channel);
                    };
                    
                    console.log('Answer generated - waiting for sender to process it');
                    
                    // Hide loader
                    this.hideLoaders();
                    
                } catch (error) {
                    console.error('Error processing offer:', error);
                    alert('Invalid offer format. Please check the offer you pasted.');
                    this.hideLoaders();
                }
            }
            
            async processReceivedAnswer() {
                const answerText = document.getElementById('answerInput').value.trim();
                if (!answerText) {
                    alert('Please paste the answer you received.');
                    return;
                }
                
                try {
                    console.log('=== PROCESSING ANSWER (SENDER SIDE) ===');
                    console.log('Raw answer text:', answerText);
                    const answer = JSON.parse(answerText);
                    console.log('Parsed answer object:', answer);
                    console.log('Answer properties:', Object.keys(answer));
                    console.log('Answer type:', answer.type);
                    console.log('Answer SDP exists:', !!answer.sdp);
                    
                    // More lenient validation - just check for essential properties
                    if (!answer || typeof answer !== 'object') {
                        console.error('Answer is not a valid object:', answer);
                        throw new Error('Invalid answer format - not an object');
                    }
                    
                    if (!answer.sdp || typeof answer.sdp !== 'string') {
                        console.error('Answer missing or invalid SDP:', answer.sdp);
                        throw new Error('Invalid answer format - missing SDP');
                    }
                    
                    // Accept any type that looks like an answer
                    if (answer.type && answer.type !== 'answer') {
                        console.error('Answer has wrong type:', answer.type);
                        throw new Error('Invalid answer format - wrong type');
                    }
                    
                    // If no type is specified, assume it's an answer
                    if (!answer.type) {
                        console.log('No type specified, assuming answer type');
                        answer.type = 'answer';
                    }
                    
                    if (!this.peerConnection) {
                        alert('No peer connection found. Please generate an offer first.');
                        return;
                    }
                    
                    await this.peerConnection.setRemoteDescription(answer);
                    console.log('Remote description set on sender side');
                    console.log('Data channel state:', this.dataChannel.readyState);
                    
                    // Connection will be established via data channel onopen event
                    console.log('Waiting for data channel to open...');
                    
                } catch (error) {
                    console.error('Error processing answer:', error);
                    alert('Invalid answer format. Please check the answer you pasted.');
                }
            }
            
            copyToClipboard(elementId) {
                const element = document.getElementById(elementId);
                element.select();
                document.execCommand('copy');
                
                // Show temporary feedback
                const originalText = element.nextElementSibling?.textContent;
                if (element.nextElementSibling && element.nextElementSibling.tagName === 'BUTTON') {
                    element.nextElementSibling.textContent = 'Copied!';
                    setTimeout(() => {
                        element.nextElementSibling.textContent = originalText || 'Copy';
                    }, 2000);
                }
            }
        }
        
        // Memory optimization: single global instance
        let appState;
        
        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing app...');
            try {
                appState = new AppState();
                console.log('AppState initialized successfully:', appState);
                console.log('AppState methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(appState)));
            } catch (error) {
                console.error('Failed to initialize AppState:', error);
                alert('Failed to initialize app: ' + error.message);
            }
        });
        
        // Global functions for button clicks (memory optimization: avoid multiple event listeners)
        function createRoom() { 
            console.log('Create room button clicked');
            console.log('appState exists:', !!appState);
            console.log('appState type:', typeof appState);
            if (appState) {
                console.log('Calling appState.createRoom()');
                appState.createRoom(); 
            } else {
                console.error('appState is not initialized!');
                alert('App not initialized. Please refresh the page.');
            }
        }
        function joinRoom() { 
            console.log('Join room button clicked');
            if (appState) appState.joinRoom(); 
        }
        function playVsAI() { 
            console.log('Play vs AI button clicked');
            if (appState) appState.playVsAI(); 
        }
        function playHotseat() { 
            console.log('Hotseat button clicked');
            if (appState) appState.playHotseat(); 
        }
        function backToLobby() { 
            console.log('Back to lobby button clicked');
            if (appState) appState.backToLobby(); 
        }
        function closeJoinModal() { 
            console.log('Close join modal button clicked');
            if (appState) appState.closeJoinModal(); 
        }
        function connectToRoom() { 
            console.log('Connect to room button clicked');
            if (appState) appState.connectToRoom(); 
        }
        function startManualHandshake() { 
            console.log('Start manual handshake button clicked');
            if (appState) appState.startManualHandshake(); 
        }
        function closeHandshakeModal() { 
            console.log('Close handshake modal button clicked');
            if (appState) appState.closeHandshakeModal(); 
        }
        function processManualAnswer() { 
            console.log('Process manual answer button clicked');
            if (appState) appState.processManualAnswer(); 
        }
        function openManualJoin() {
            console.log('Open manual join button clicked');
            if (appState) appState.openManualJoin();
        }
        function processReceivedOffer() {
            console.log('Process received offer button clicked');
            if (appState) appState.processReceivedOffer();
        }
        function startCreateMode() {
            console.log('Start create mode button clicked');
            if (appState) appState.startCreateMode();
        }
        function startJoinMode() {
            console.log('Start join mode button clicked');
            if (appState) appState.startJoinMode();
        }
        function processReceivedAnswer() {
            console.log('Process received answer button clicked');
            if (appState) appState.processReceivedAnswer();
        }
        function resetHandshakeModal() {
            console.log('Reset handshake modal button clicked');
            if (appState) appState.resetHandshakeModal();
        }
        function copyToClipboard(elementId) {
            console.log('Copy to clipboard button clicked');
            if (appState) appState.copyToClipboard(elementId);
        }
        
        function rematchGame() {
            console.log('Rematch button clicked');
            if (appState) appState.rematchGame();
        }
        
        // Debug test function
        function testCreateRoom() {
            console.log('=== DEBUG TEST START ===');
            console.log('Testing create room functionality...');
            
            // Check if appState exists
            console.log('appState exists:', !!appState);
            if (appState) {
                console.log('appState type:', typeof appState);
                console.log('appState methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(appState)));
                
                // Check DOM elements
                const lobbyEl = document.getElementById('lobby');
                const roomInfoEl = document.getElementById('roomInfo');
                const roomIdEl = document.getElementById('roomId');
                
                console.log('DOM elements:', {
                    lobby: lobbyEl,
                    roomInfo: roomInfoEl,
                    roomId: roomIdEl
                });
                
                // Test the createRoom method directly
                try {
                    appState.createRoom();
                } catch (error) {
                    console.error('Error calling createRoom:', error);
                }
            } else {
                console.error('appState is null or undefined!');
            }
            console.log('=== DEBUG TEST END ===');
        }
        
        // Memory snapshot export function
        function exportMemorySnapshot() {
            if (performance.memory) {
                const memory = performance.memory;
                const snapshot = {
                    usedJSHeapSize: `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                    totalJSHeapSize: `${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
                    jsHeapSizeLimit: `${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(snapshot, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'memory-snapshot.json';
                a.click();
                URL.revokeObjectURL(url);
            }
        }
    </script>
</body>
</html>
